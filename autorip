#!/usr/bin/env python3
# Copyright 2019 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import argparse
import os, sys
from viddin import viddin
import subprocess

VIDEO_EXT = [".mkv", ".mp4", ".webm"]
LOCK_DIR = "/var/lock"
RIPPED_DIR = "ripped"

def build_argparser():
  parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
  parser.add_argument("directory", help="directory to scan and rip")
  parser.add_argument("--check", action="store_true", help="check if there's anything to rip and exit with 0 if there is")
  # parser.add_argument("--flags", default=FLAGS, help="flags to pass to rip-video")
  parser.add_argument("--outtype", default=".mkv", help="file type to rip to")
  parser.add_argument("--ripdir", default=RIPPED_DIR,
                      help="directory to put ripped files into")
  parser.add_argument("--debug", action="store_true", help="pass debug flag")
  return parser

def create_lock():
  lock_file = os.path.basename(__file__) + ".pid"
  lock_path = os.path.join(LOCK_DIR, lock_file)
  if os.path.exists(lock_path):
    with open(lock_path, "r") as f:
      pid = f.readline()
      try:
        pid = int(pid)
      except ValueError:
        pid = None
      if pid:
        try:
          os.kill(pid, 0)
        except OSError:
          pass
        else:
          return None
  with open(lock_path, "w") as f:
    f.write(str(os.getpid()))
    f.write("\n")
  return lock_path

def get_videos(path, ignore):
  result = []
  ignore = os.path.commonpath([ignore])
  for root, dirs, files in os.walk(path):
    if ignore == os.path.commonpath([ignore, root]):
      continue
    for file in files:
      base, ext = os.path.splitext(file)
      if ext not in VIDEO_EXT:
        continue
      result.append(os.path.join(root, file))
  result.sort()
  return result

def rip_video(path, basedir, ripdir, outtype, debugFlag=False):
  subdir = os.path.relpath(os.path.dirname(path), basedir)
  subdir = os.path.join(basedir, ripdir, subdir)
  output = os.path.join(subdir, os.path.basename(path))
  p, e = os.path.splitext(output)
  output = p + outtype
  log = p + ".autolog"

  resolution = viddin.getResolution(path)
  bluray = False
  if resolution[0] > 1000 or resolution[1] >= 700:
    bluray = True

  cmd = ["rip-video", "--lang=eng"]
  if bluray:
    cmd.extend(["--bluray"])
  else:
    # FIXME - detect telecine and choose between --tv and --film
    cmd.extend(["--tv"])

  cmd.extend([path, output])
  os.makedirs(subdir, exist_ok=True)
    
  if debugFlag:
    print(cmd)
  if not sys.stdout.isatty():
    with open(log, "w") as logf:
      p = subprocess.run(cmd, stdout=logf, stderr=subprocess.STDOUT)
  else:
    print("Ripping", path)
    p = subprocess.run(cmd)
  return p.returncode == 0

def main():
  args = build_argparser().parse_args()

  exit_code = 0
  lock = create_lock()
  if not lock:
    # FIXME - check how long pid has been running and print message if more than several hours
    exit_code -1

  if exit_code == 0:
    if os.path.isabs(args.ripdir):
      parent = os.path.abspath(args.directory)
      if os.path.commonpath([parent]) != os.path.commonpath([parent, args.ripdir]):
        print("ripdir must be in directory")
        exit_code = -2
      else:
        args.ripdir = os.path.relpath(ripdir, parent)

  if args.outtype[0] != '.':
    args.outtype = "." + args.outtype
        
  if exit_code == 0:
    videos = get_videos(args.directory, os.path.join(args.directory, args.ripdir))
    if args.check:
      exit_code = len(videos) == 0
    else:
      for v in videos:
        ripped = rip_video(v, args.directory, args.ripdir, args.outtype, debugFlag=args.debug)
        if ripped:
          print("Ripped", v)
          os.unlink(v)
          try:
            os.rmdir(os.path.dirname(v))
          except OSError:
            pass
        else:
          print("FAILED", v)
          exit_code += 1

  os.unlink(lock)
  
  return exit_code

if __name__ == '__main__':
  exit(main() or 0)
