#!/usr/bin/env python
#
# Copyright 2016 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import os
import datetime
import sys
from operator import itemgetter
import re
import argparse
import glob
import math
import tvdb_api
import csv

EP_ID = 0
EP_SEASON = 1
EP_NUM = 2
EP_DVDSEASON = 3
EP_DVDEPISODE = 4
EP_TITLE = 5
EP_ORIGDATE = 6

SEG_POS = 0
SEG_LEN = 1
SEG_TYPE = 2
SEG_BLACK = 3
SEG_SILENCE = 4
SEG_FLAGS = 5

CSV_EPISODE = 0
CSV_DVDEP = 1
CSV_ORIGDATE = 2
CSV_TITLE = 3

MARGIN = 5

TYPE_TITLE = "Title"
TYPE_CREDITS = "Credits"
TYPE_QUICKIE = "Quickie"
TYPE_SHORT = "Short"

ftr = [3600,60,1]

parser = argparse.ArgumentParser()
parser.add_argument("series", help="Name of series on thetvdb.com")
parser.add_argument("files", nargs="*", help="examine only these files")
parser.add_argument("--quickies", default="18-56", help="range of quickie length")
parser.add_argument("--minlength", default=320, help="minimum short length")
parser.add_argument("--titlelen", help="length in seconds of opening titles", default=60)
parser.add_argument("--creditlen", help="length in seconds of end credits", default=35)
parser.add_argument("--dvdmissing", action="store_true", help="use episode data when dvd info is missing")
parser.add_argument("--quiet", action="store_true", help="don't print errors about missing DVD info")
parser.add_argument("--split", action="store_true", help="Split and rename instead of printing")
parser.add_argument("--notranscode", action="store_true", help="Split video without transcoding")
parser.add_argument("--debug", action="store_true", help="Turn on debug output")
args = parser.parse_args()

def findBlack(filename):
  video, ext = os.path.splitext(filename)
  if not os.path.exists("%s.split" % video):
    print "Finding black"
    os.system("find-black --duration 0.1 %s %s.split > /dev/null" % (filename, video))

def findSilence(filename):
  video, ext = os.path.splitext(filename)
  if not os.path.exists("%s.sil" % video):
    print "Finding silence"
    os.system("find-silence --threshold 40 --duration 0.1 %s %s.sil > /dev/null" % (filename, video))

def bestSilence(best, filename):
  video, ext = os.path.splitext(filename)

  bestsil = None
  with open(video + ".sil") as f:
    for line in f:
      info = line.split()
      begin = float(info[1])
      end = float(info[2])
      center = begin + (end - begin) / 2
      diff = abs(center - best[0])
      if ((begin >= best[1] and begin <= best[2]) or (end >= best[1] and end <= best[2]) or \
            (best[1] >= begin and best[1] <= end) or (best[2] >= begin and best[2] <= end)) \
            and (not bestsil or diff < bestsil[0]):
        bestsil = [diff, center, begin, end]

  if bestsil:
    begin = bestsil[2]
    if begin < best[1]:
      begin = best[1]
    end = bestsil[3]
    if end > best[2]:
      end = best[2]
    split = begin + (end - begin) / 2
    return split

  return None

def segmentRow(position, length, segType=None, segBlack=None, segSilence=None, segFlags=None):
  return [position, length, segType, segBlack, segSilence, segFlags]

def loadSplits(filename):
  video, ext = os.path.splitext(filename)
  splits = [[0.0, None]]
  with open(video + ".split") as f:
    for line in f:
      info = line.split()
      begin = float(info[1])
      end = float(info[2])
      center = begin + (end - begin) / 2
      black = [center, begin, end]
      sil = [bestSilence(black, filename), end - begin]
      if not sil[0]:
        sil[0] = -black[0]
      splits.append(sil)

  splits.append([vlen, 0])

  return splits

# FIXME - make this an option, numbering may not match anything
# depending on how DVD chapters were split
def guessEpisode(filename):
  m = re.search("([0-9]+)x([0-9]+)", filename)
  if not m:
    m = re.search("[Ss]([0-9]+)[Ee]([0-9]+)", filename)
  if m:
    sn = int(m.group(1))
    ep = int(m.group(2))
    for row in episodes:
      if sn == row[EP_DVDSEASON] and ep == int(row[EP_DVDEPISODE]):
        return row
  return None

def getShortTotal(segment):
  ci = segments.index(segment)
  slen = 0
  for segment in segments[ci:len(segments) - 1]:
    if segment[SEG_TYPE]:
      break
    slen += segment[SEG_LEN]
  return slen

def shortTooShort(segment):
  if segment[SEG_TYPE] == TYPE_SHORT and segment[SEG_LEN] < args.minlength:
    ci = newc.index(segment)
    prevs = newc[ci - 1]
    nexts = newc[ci + 1]
    if args.debug:
      print "TOO SHORT", segment, prevs, nexts
    if prevs[SEG_TYPE] != TYPE_QUICKIE or nexts[SEG_TYPE] == TYPE_CREDITS:
      prevs[SEG_LEN] += segment[SEG_LEN]
      prevs[SEG_TYPE] = segment[SEG_TYPE]
    else:
      nexts[SEG_POS] = segment[SEG_POS]
      nexts[SEG_LEN] += segment[SEG_LEN]
      nexts[SEG_TYPE] = segment[SEG_TYPE]
    return True
  return False

def loadChapters(filename):
  chap = 0
  chapters = []
  with os.popen("ffmpeg -i \"" + filename + "\" -f ffmetadata 2>&1 | grep 'Chapter #'") as f:
    for line in f:
      seconds = float(re.sub(",", "", line.split()[3]))
      chapters.append(seconds)
      chap += 1
      if not args.split:
        print "# Chapter %i: %s %f" % (chap, datetime.timedelta(seconds = seconds), seconds)
  return chapters

def nearestChapter(position):
  for chap in chapters:
    if abs(position - chap) < 10:
      return chap
  return None

def printSegments(segments):
  for segment in segments:
    nf = len(segment)
    pos = segment[SEG_POS]
    slen = segment[SEG_LEN]
    stype = segment[SEG_TYPE]

    if pos < 0:
      sys.stdout.write("-")
    else:
      sys.stdout.write(" ")

    if stype:
      sys.stdout.write(stype[0])
    else:
      sys.stdout.write(" ")

    sys.stdout.write(": %9.4f %9.4f" % (abs(pos), slen))
    sys.stdout.write("\n")

  sys.stdout.write("\n")
  sys.stdout.flush()

quickies = []
if re.match("^[-+]?[0-9]+(\.[0-9]+)?$", args.quickies):
  quickies.append(int(args.quickies))
  quickies.append(quickies[0])
elif re.match("^[0-9]+(.[0-9]+)?-[0-9]+(\.[0-9]+)?$", args.quickies):
  times = args.quickies.split("-")
  quickies.append(int(times[0]))
  quickies.append(int(times[1]))

args.titlelen = float(args.titlelen)
args.creditlen = float(args.creditlen)
args.minlength = float(args.minlength)
  
episodes = []
if os.path.isfile(args.series):
  f = open(args.series, 'rU')
  try:
    reader = csv.reader(f)
    for row in reader:
      epnum = re.split(" *x *", row[CSV_EPISODE])
      dvdnum = re.split(" *x *", row[CSV_DVDEP])
      epid = epnum[0] + "x" + epnum[1].zfill(2)
      info = [epid, int(epnum[0]), int(epnum[1]), int(dvdnum[0]), float(dvdnum[1]), \
                row[CSV_TITLE], row[CSV_ORIGDATE]]
      episodes.append(info)
  finally:
    f.close()

else:
  t = tvdb_api.Tvdb()
  show = t[args.series]
  for season in show:
    for epnum in show[season]:
      episode = show[season][epnum]
      epid = episode['seasonnumber'] + "x" + episode['episodenumber'].zfill(2)
      if episode['dvd_season'] and episode['dvd_episodenumber']:
        info = [epid, int(episode['seasonnumber']), int(episode['episodenumber']), \
                  int(episode['dvd_season']), float(episode['dvd_episodenumber']), \
                  episode['episodename'], episode['firstaired']]
        episodes.append(info)
      elif not args.quiet:
        print "No DVD info for"
        print episode
        if args.dvdmissing:
          info = [epid, int(episode['seasonnumber']), int(episode['episodenumber']), \
                    int(episode['seasonnumber']), float(episode['episodenumber']), \
                    episode['episodename'], episode['firstaired']]
          episodes.append(info)
episodes = sorted(episodes, key=itemgetter(EP_DVDSEASON, EP_DVDEPISODE))

if args.files:
  videos = args.files
else:
  videos = [file for file in glob.glob("[0-9]x[0-9][0-9].mkv")]
  videos.sort()

transcode = "--transcode"
if args.notranscode:
  transcode = ""
  
for filename in videos:
  video, ext = os.path.splitext(filename)

  episode = guessEpisode(filename)
  epindex = episodes.index(episode)
  chapters = loadChapters(filename)

  numshorts = 0
  shortindex = epindex
  dvdep = int(episode[EP_DVDEPISODE])
  dvdep2 = int(episodes[shortindex][EP_DVDEPISODE])
  while int(episodes[shortindex][EP_DVDEPISODE]) == int(episode[EP_DVDEPISODE]):
    numshorts += 1
    shortindex += 1
    dvdep2 = int(episodes[shortindex][EP_DVDSEASON])
    
  findBlack(filename)
  findSilence(filename)

  cmd = "vidinf %s | grep ID_LENGTH | sed -e 's/ID_LENGTH=//'" % filename
  process = os.popen(cmd)
  vlen = float(process.read())
  process.close()

  splits = loadSplits(filename)

  segments = []
  for i in range(len(splits) - 1):
    cc = splits[i][SEG_POS]
    cn = splits[i+1][SEG_POS]
    segments.append([cc, abs(cn) - abs(cc), None, splits[i][SEG_LEN]])

  if abs(segments[0][SEG_LEN]) < 3:
    del segments[0]
    
  while abs(segments[-1][SEG_LEN]) < args.creditlen:
    segments[-2][SEG_LEN] = abs(segments[-2][SEG_LEN]) + abs(segments[-1][SEG_LEN])
    del segments[-1]

  if segments[-1][SEG_LEN] < args.creditlen or segments[-1][SEG_LEN] - args.creditlen < 10:
    segments[-1][SEG_TYPE] = TYPE_CREDITS
  else:
    segments.append([vlen, 0.0, TYPE_CREDITS, 0.0])

  if args.debug:
    printSegments(segments)
  
  didtitle = False
  since = 0
  pos = 0
  endpos = len(segments) - 1
  while pos < endpos:
    segment = segments[pos]
    prevc = None
    if pos:
      prevc = segments[pos - 1]
    nextc = segments[pos + 1]

    clen = segment[SEG_LEN]
    qpercent = clen / quickies[0] * 100

    if clen >= quickies[0] and clen <= quickies[1] and \
          (segment[SEG_POS] > 0 or \
             ((not prevc or prevc[SEG_TYPE]) and \
                (segment[SEG_POS] > 0 or prevc[SEG_TYPE] != TYPE_QUICKIE)) or \
             segment[SEG_BLACK] > 2):
      quickie = True
      if len(chapters) and prevc and prevc[SEG_TYPE] == TYPE_QUICKIE:
        achap = nearestChapter(abs(segment[SEG_POS]))
        bchap = nearestChapter(abs(nextc[SEG_POS]))
        if not achap and not bchap:
          quickie = False
          if args.debug:
            print "FAR"
      if quickie:
        segment[SEG_TYPE] = TYPE_QUICKIE
        since = 0
        if args.debug:
          print "QUICKIE", segment
        if prevc and prevc[SEG_TYPE] == TYPE_QUICKIE:
          chap = nearestChapter(abs(prevc[SEG_POS]))
          if chap and abs(chap - prevc[SEG_POS]) < abs(chap - segment[SEG_POS]):
            segment[SEG_TYPE] = None
          else:
            prevc[SEG_TYPE] = None
    elif abs(clen - args.titlelen) < MARGIN and not didtitle:
      segment[SEG_TYPE] = TYPE_TITLE
      since = 0
      didtitle = True
    elif clen < quickies[0] and segment[SEG_POS] > 0 and nextc[SEG_POS] < 0 and \
          clen + nextc[SEG_LEN] >= quickies[0] and clen + nextc[SEG_LEN] <= quickies[1] and \
          qpercent > 50 and (not prevc or prevc[SEG_TYPE] != TYPE_QUICKIE):
      if args.debug:
        print "JOIN", qpercent, clen, segment, nextc
      segment[SEG_LEN] += nextc[SEG_LEN]
      segment[SEG_TYPE] = TYPE_QUICKIE
      since = 0
      del segments[pos + 1]
      endpos -= 1
      clen = segment[SEG_LEN]
      nextc = segments[pos + 1]
      while clen > quickies[0] and nextc[SEG_BLACK] < 0.6 and \
            clen + nextc[SEG_LEN] < quickies[1] and nextc[SEG_POS] < 0:
        if args.debug:
          print "DOUBLE JOIN", qpercent, clen, segment, nextc
        segment[SEG_LEN] += nextc[SEG_LEN]
        segment[SEG_TYPE] = TYPE_QUICKIE
        del segments[pos + 1]
        endpos -= 1
        clen = segment[SEG_LEN]
        nextc = segments[pos + 1]
    else:
      since += clen
    pos += 1

  for seg in segments:
    pos = abs(seg[SEG_POS])
    chap = nearestChapter(pos)
    if chap and abs(pos - chap) < 2 and not seg[SEG_TYPE]:
      seg[SEG_TYPE] = TYPE_SHORT
    
  if args.debug:
    print
    printSegments(segments)

  slen = 0
  for segment in segments:
    if not segment[SEG_TYPE]:
      slen += abs(segment[SEG_LEN])
  slen = slen / numshorts
  if args.debug:
    print "Average short len:", slen
  
  newc = []
  last = None
  clen = 0
  for curc in segments:
    pos = segments.index(curc)
    nextc = None
    if pos < len(segments) - 1:
      nextc = segments[pos + 1]

    if curc[SEG_TYPE]:
      if last:
        newc.append([last, clen, TYPE_SHORT])
        if args.debug:
          print "SHORT", clen
      newc.append([curc[SEG_POS], curc[SEG_LEN], curc[SEG_TYPE]])
      last = None
      continue

    if not last:
      last = curc[SEG_POS]
      clen = 0
      if args.debug:
        print "REMAIN", getShortTotal(curc)
    overpercent = (clen + abs(curc[SEG_LEN]) - slen) / abs(curc[SEG_LEN]) * 100
    if overpercent > 50 and nextc[SEG_POS] < 0:
      if args.debug:
        print "OVER", overpercent, curc[SEG_POS], nextc[SEG_POS]
      newc.append([last, clen, TYPE_SHORT])
      last = curc[SEG_POS]
      clen = 0
    clen += abs(curc[SEG_LEN])

    underpercent = (slen - clen) / slen * 100
    if clen > slen or (clen > args.minlength and clen + nextc[SEG_LEN] > slen and nextc[SEG_POS] > 0) or \
          (nextc[SEG_POS] > 0 and underpercent > 0 and underpercent < 8 and clen + nextc[SEG_LEN] < slen):
      newc.append([last, clen, TYPE_SHORT])
      last = None
      if args.debug:
        print "END", clen, slen, curc[SEG_POS], nextc[SEG_POS]

  pos = 0
  endpos = len(newc)
  while pos < endpos:
    if shortTooShort(newc[pos]):
      del newc[pos]
      endpos -= 1
    else:
      pos += 1
  
  newc.append([vlen, 0.0, None])

  for seg in newc:
    pos = abs(seg[SEG_POS])
    chap = nearestChapter(pos)
    if chap:
      if pos > chap and pos - chap < 2:
        print "# Warning: best found split %s was after chapter %s" \
            % (datetime.timedelta(seconds = pos), datetime.timedelta(seconds = chap))
        pos = chap
      elif chap - pos < 8:
        print "# Warning: best found split %s preceeded chapter %s" \
            % (datetime.timedelta(seconds = pos), datetime.timedelta(seconds = chap))
        pos = chap
      seg[SEG_POS] = pos
    
  if args.debug:
    print
    printSegments(newc)
    
  quickie = 0
  epnum = 0
  for current in newc[:-1]:
    nextc = newc[newc.index(current) + 1]
    ctype = current[SEG_TYPE]
    if ctype == TYPE_QUICKIE:
      quickie += 1
      title = "Quickie %i" % quickie
      ep = episodes[epindex + epnum]
      eptitle = "%s.%i %s%s" % (video, quickie + epnum, title, ext)
    elif ctype == TYPE_SHORT:
      ep = episodes[epindex + epnum]
      title = re.sub("[:/]", "-", re.sub("[.!?]$", "", ep[EP_TITLE]))
      eptitle = "%s.%i %s%s" % (video, quickie + epnum + 1, title, ext)
#      eptitle = "%s %s%s" % (episode[EP_ID], title, ext)
      epnum += 1

    begin = abs(current[SEG_POS])
    end = abs(nextc[SEG_POS])
    
    if args.split:
      if ctype == TYPE_QUICKIE or ctype == TYPE_SHORT:
        temp = video + "_tmp" + ext
        cmd = "split-video %s --output \"%s\" \"%s\" %f-%f" % (transcode, temp, filename, begin, end)
        print cmd
        os.system(cmd)
        cmd = "adjust-volume \"%s\" \"%s\" > /dev/null 2>&1" % (temp, eptitle)
        print cmd
        os.system(cmd)
        os.remove(temp)        
    else:
      print "# " + ctype, end - begin
      if ctype == TYPE_SHORT or ctype == TYPE_QUICKIE:
        print "# " + title
      print begin

  if epnum != numshorts:
    print "# WRONG number of shorts:", epnum, numshorts
