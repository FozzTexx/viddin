#!/usr/bin/env python3
# -*- python -*-
#
# Copyright 2019 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import argparse
import os
import json
import xmltodict
import re
import tempfile
import shutil
import pty
import subprocess

def build_argparser():
  parser = argparse.ArgumentParser()
  parser.add_argument("files", nargs="*", help="input files")
  parser.add_argument("dest", help="output file")
  return parser

def trackWithUid(uid, tracks):
  for track in tracks:
    if 'uid' in track and uid == track['uid']:
      return track
  return None

def decodeTimecode(tc):
  fraction = 0
  if re.match(".*\.[0-9]+$", tc):
    parts = re.split("\.", tc)
    fraction = float("."+parts[1])
    tc = parts[0]

  for m in re.finditer(r'[0-9]', tc):
    pass
  tc = tc[:m.end(0)]

  seconds = sum(float(x) * 60 ** i for i,x in enumerate(reversed(tc.split(":"))))
  seconds += fraction
  return seconds

def getLengthMKV(path):
  cmd = "mkvmerge -i -F json \"%s\"" % (path)
  process = os.popen(cmd)
  jstr = process.read()
  process.close()
  jinfo = json.loads(jstr)

  tracks = []
  for track in jinfo['tracks']:
    info = {'type': track['type']}
    info['rv_track_id'] = track['id']
    info.update(track['properties'])
    tracks.append(info)

  cmd = "mkvextract tags \"%s\"" % (path)
  process = os.popen(cmd)
  xstr = process.read()
  process.close()
  xstr = xstr.strip()
  if len(xstr):
    xinfo = xmltodict.parse(xstr)['Tags']
    xlist = []
    for track in xinfo:
      xi1 = xinfo[track]
      for xi2 in xi1:
        xdict = {}
        if 'Targets' in xi2:
          xi3 = xi2['Targets']
          if xi3 and 'TrackUID' in xi3:
            xdict['TrackUID'] = int(xi3['TrackUID'])
        if 'Simple' in xi2:
          xi3 = xi2['Simple']
          if type(xi3) == list:
            for xi4 in xi3:
              xdict[xi4['Name']] = xi4['String']
          else:
            xdict[xi3['Name']] = xi3['String']
        xlist.append(xdict)

    for track in xlist:
      if 'TrackUID' in track:
        tt = trackWithUid(track['TrackUID'], tracks)
        if tt:
          tt.update(track)

  tlen = None
  for track in tracks:
    if track['type'] == "video" and 'DURATION' in track:
      alen = decodeTimecode(track['DURATION'])
      if not tlen or alen > tlen:
        tlen = alen

  if not tlen:
    container = jinfo['container']['properties']
    if 'duration' in container:
      tlen = int(container['duration'])
      tlen /= 1000000000
  return tlen

def loadChapters(filename):
  chapters = []
  with os.popen("ffmpeg -i \"" + filename + "\" -f ffmetadata 2>&1 | grep 'Chapter #'") as f:
    for line in f:
      fields = line.split()
      begin = float(re.sub(",", "", fields[3]))
      end = float(fields[5])
      chapters.append(begin)
  return chapters

def getLength(filename, title=None, chapters=None):
  clen = []
  if title:
    cmd = "lsdvd -t %s -c \"%s\"" % (title, filename)
    cmd += " 2>/dev/null"
    with os.popen(cmd) as f:
      lines = f.read().splitlines()
    for line in lines:
      info = line.split()
      if len(info) < 1:
        continue
      if info[0] == "Title:":
        tlen = findLength(info)
      elif info[0] == "Chapter:":
        clen.append(findLength(info))
    if chapters:
      if chapters.index("-"):
        chaps = chapters.split("-")
      else:
        chaps = [chapters, chapters]
      tlen = 0
      for c in range(int(chaps[0]), int(chaps[1]) + 1):
        tlen += clen[c]
  else:
    _, ext = os.path.splitext(filename)
    if ext == ".mkv":
      tlen = getLengthMKV(filename)
    else:
      cmd = "vidinf \"%s\" | grep ID_LENGTH | sed -e 's/ID_LENGTH=//'" % filename
      process = os.popen(cmd)
      tlen = float(process.read())
      process.close()

    if chapters:
      if chapters.index("-"):
        chaps = chapters.split("-")
      else:
        chaps = [chapters, chapters]
      chaptimes = loadChapters(filename)
      chaptimes.append(tlen)
      tlen = abs(chaptimes[int(chaps[1])] - chaptimes[int(chaps[0]) - 1])

  return tlen

def runCommand(cmd):
  width = os.get_terminal_size().columns
  pos = 0
  master, slave = pty.openpty()
  with subprocess.Popen(cmd, shell=True, stdin=slave, stdout=slave, stderr=slave,
                       close_fds=True) as p:
    m = os.fdopen(master, 'r')
    os.close(slave)
    try:
      while True:
        c = m.read(1)
        if c == '\n':
          c = '\r'
        if c == '\r' or width == 0 or pos < width - 2:
          sys.stdout.write(c)
          pos += 1
          if c == '\r':
            pos = 0
        sys.stdout.flush()
    except:
      pass
  return

def main():
  args = build_argparser().parse_args()
  longest = None
  for vid in args.files:
    length = getLength(vid)
    if not longest or length > longest[1]:
      longest = (vid, length)

  cmd = "vidinf \"%s\" | egrep 'ID_VIDEO_WIDTH|ID_VIDEO_HEIGHT'" % (longest[0])
  process = os.popen(cmd)
  size = process.read()
  process.close()
  size = size.strip().split()
  dsize = {k:int(v) for k,v in (x.split("=") for x in size)}
  print(dsize)

  tmpdir = tempfile.mkdtemp()
  print(tmpdir)
  
  inputs = []
  for vid in args.files:
    if vid == longest[0]:
      inputs.append(os.path.abspath(vid))
    else:
      tmp, ext = os.path.splitext(vid)
      tmp += "_%i" % (args.files.index(vid)) + ext
      tmp = os.path.join(tmpdir, tmp)
      cmd = "ffmpeg -i \"%s\" -vf scale=%i:%i -c copy -vcodec libx264 -map 0 %s" % \
          (vid, dsize['ID_VIDEO_WIDTH'], dsize['ID_VIDEO_HEIGHT'], tmp)
      print(cmd)
      runCommand(cmd)
      inputs.append(tmp)

  # mergetxt = os.path.join(tmpdir, "merge.txt")
  # f = open(mergetxt, "w")
  # for vid in inputs:
  #   f.write("file '%s'\n" % (vid))
  # f.close()
  # cmd = "ffmpeg -f concat -i %s -c copy \"%s\"" % (mergetxt, args.dest)

  cmd = "mkvmerge -o \"%s\"" % (args.dest)
  for vid in inputs:
    idx = inputs.index(vid)
    if idx:
      cmd += " +"
    cmd += " \"%s\"" % (vid)

  print(cmd)
  runCommand(cmd)

  shutil.rmtree(tmpdir)

  return

if __name__ == '__main__':
  exit(main() or 0)
