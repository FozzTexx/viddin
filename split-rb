#!/usr/bin/env python
#
# Copyright 2016 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import sys
import os
import datetime
import csv
import re
import argparse

creditlen = [78, 55]
bumperlen = [10, 20]
ftr = [3600,60,1]
titles = 0

CSV_EPISODE = 0
CSV_DVDEP = 1
CSV_ORIGDATE = 2
CSV_TITLE = 3

parser = argparse.ArgumentParser()
parser.add_argument("filename", help="video file to split")
parser.add_argument("titles", nargs='?', help="csv file with episode information")
parser.add_argument("--titlelen", help="length in seconds of opening titles")
parser.add_argument("--creditlen", help="length in seconds of end credits")
parser.add_argument("--bumpermin", help="minimum length in seconds of bumpers")
parser.add_argument("--bumpermax", help="maximum in seconds of bumpers")
parser.add_argument("--prebumper", action="store_true", help="a bumper can occur before first chapter")
args = parser.parse_args()

if args.titlelen:
  creditlen[0] = float(args.titlelen)
if args.creditlen:
  creditlen[1] = float(args.creditlen)
if args.bumpermin:
  bumperlen[0] = float(args.bumpermin)
if args.bumpermax:
  bumperlen[1] = float(args.bumpermax)

ep = re.split("x|\\.", args.filename)
season = int(ep[0])
episode = int(ep[1])

if season == 3 or season == 4 or (season == 2 and episode >= 44):
  creditlen[1] = 90
if season == 3 and episode == 17:
  creditlen[1] = 80
if season == 4 and episode == 3:
  creditlen[1] = 77.9
if season == 4 and episode == 11:
  creditlen[1] = 83
if season == 4 and episode == 16:
  creditlen[1] = 80
if season == 2 and episode == 8:
  bumperlen[0] = 9.8
if season == 2 and episode == 20:
  bumperlen[0] = 9.5
if season == 2 and episode == 39:
  bumperlen[0] = 9.7
if season == 2 and episode == 40:
  bumperlen[0] = 9.8
if season == 4 and episode == 3:
  bumperlen[0] = 11

if args.titles:
  titles = 1
  episodes = []
  f = open(args.titles, 'rU')
  try:
    reader = csv.reader(f)
    for row in reader:
      epnum = re.split(" +x +", row[CSV_EPISODE])
      dvdnum = re.split("( +x +)|\\.", row[CSV_DVDEP])
      episodes.append([int(epnum[0]), int(epnum[1]), int(dvdnum[2]), row[CSV_TITLE]])
  finally:
    f.close()

  for row in episodes:
    if row[0] == season and row[2] == episode:
      epindex = episodes.index(row)
      break

  # FIXME - sort by DVD order
    
video, ext = os.path.splitext(args.filename)

with open(video + ".split", "r") as f:
  bmarkers = []
  for line in f:
    if line.strip().startswith("#"):
      continue
    last_end = 0.0
    points = line.split()
    if len(bmarkers):
      last_end = (bmarkers[-1][1] - bmarkers[-1][0]) / 2 + bmarkers[-1][0]
    seglen = float(points[1]) - last_end
    bmarkers.append([float(points[1]), float(points[2]), seglen])

with os.popen("mediainfo " + args.filename + "| grep Chapter") as f:
  cmarkers = []
  for line in f:
    # FIXME - mediainfo incorrectly puts leading zero on decimal part of seconds
    tcode = line.split()[0]
    seconds = sum([a*b for a,b in zip(ftr, map(float, tcode.split(':')))])

    print '# Chapter marker ' + str(seconds)

    # Special fix for R&B episodes that have a chapter marker in the wrong place
    if season == 3 and episode == 20 and seconds == 658.398:
      seconds = 670.891
    if season == 4 and episode == 6 and seconds == 677.499:
      seconds = 689.650
    if season == 4 and episode == 8 and seconds == 660.097:
      seconds = 670.998
    cmarkers.append(seconds)

with os.popen("vidinf " + args.filename + "|grep ID_LENGTH") as f:
  for line in f:
    totallen = float(re.sub("ID_LENGTH=", "", line))
    break
    
def printTitle(epindex, epnum, segnum):
  row = episodes[epindex + epnum]
  eptitle = re.split(" - ", row[3])
  print "# Title: " + video + "_" + str(segnum).zfill(3) + ext,
  print "\"" + eptitle[0] + "\"",
  print "\"" + str(row[0]) + "x" + str(row[1]).zfill(3),
  if len(eptitle) > 1:
    print eptitle[1] + ext + "\"",
  else:
    print eptitle[0] + ext + "\"",
  print
  
segnum = 2
epnum = 0
for chap in cmarkers:
  if chap < creditlen[0]:
    if chap > 0.0:
      if titles:
        printTitle(epindex, epnum, segnum - 1)
      epnum += 1
    continue

  for black in bmarkers:
    bindex = bmarkers.index(black)
    black2 = bmarkers[bindex+1]
    if chap >= black[0] and chap <= black2[0]:
      if (epnum or args.prebumper) and black[2] >= bumperlen[0] and black[2] <= bumperlen[1]:
        bumper = black[0] - black[2]
        print "# Bumper: ", datetime.timedelta(seconds = bumper)
        print bumper
        segnum += 1
#      else:
#        print "# Bumper fail: " + str(black[2])

      seg = black[0] + (black[1] - black[0]) / 2
      if seg > chap:
        seg = chap
      print "# Segment: ", datetime.timedelta(seconds = seg)
      if titles:
        printTitle(epindex, epnum, segnum)
      print seg
      segnum += 1
      epnum += 1
      break

for black in reversed(bmarkers):
  if totallen - black[0] >= creditlen[1]:
    print "# Credits: ", datetime.timedelta(seconds = black[0] + (black[1] - black[0]) / 2)
    print black[0] + (black[1] - black[0]) / 2
    break
