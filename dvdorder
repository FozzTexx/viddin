#!/usr/bin/env python
#
# Copyright 2016 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import tvdb_api
import sys
from operator import itemgetter
import argparse
import glob
import os
import re
import sys
import math
import csv

reload(sys)
sys.setdefaultencoding('utf-8')

EPID = 0
DVDSEASON = 1
DVDEPISODE = 2
TITLE = 3
ORIGDATE = 4

CSV_EPISODE = 0
CSV_DVDEP = 1
CSV_ORIGDATE = 2
CSV_TITLE = 3

TVDB_DVDSEASON = "dvd_season"
TVDB_DVDEPNUM = "dvd_episodenumber"
if tvdb_api.__version__ >= 2:
  TVDB_DVDSEASON = "dvdSeason"
  TVDB_DVDEPNUM = "dvdEpisodeNumber"

# FIXME - add option to keep dvd order when renaming
parser = argparse.ArgumentParser()
parser.add_argument("series", help="Name of series on thetvdb.com")
parser.add_argument("--rename", action="store_true", help="rename files to match dvd order")
parser.add_argument("--dvdmissing", action="store_true", help="use episode data when dvd info is missing")
parser.add_argument("--dvdignore", action="store_true", help="ignore dvd episode data")
parser.add_argument("--enumerate", action="store_true", help="Episodes are in order but may have gaps")
parser.add_argument("--first", default=1, help="Start enumeration at this number")
parser.add_argument("--minsize", help="Ignore videos smaller than this")
parser.add_argument("--dvdorder", action="store_true", help="keep episodes in DVD order")
parser.add_argument("--airedorder", action="store_true", help="episodes are currently in aired order")
parser.add_argument("--csv", action="store_true", help="output data as csv")
parser.add_argument("--quiet", action="store_true", help="don't print errors about missing DVD info")
parser.add_argument("--glob", help="pattern for finding videos", default="[0-9]x[0-9][0-9].mkv")
parser.add_argument("--dryrun", action="store_true", help="Don't actually rename files")
args = parser.parse_args()
  
def formatEpisodeID(season, epnum):
  num = 0
  for row in dvdorder:
    if row[DVDSEASON] == season:
      num += 1
  digits = int(math.floor(math.log(num, 10)) + 1)
  if digits < 2:
    digits = 2
  epid = "%%ix%%0%ii" % digits
  return epid % (season, epnum)

def findVideo(episode):
  guess = "\\b" + formatEpisodeID(episode[DVDSEASON], int(episode[DVDEPISODE])) + "\\b"
  indices = [i for i, x in enumerate(videos) if re.search(guess, x)]
  if not len(indices):
    guess = "\\b[sS]%02i[eE]%02i\\b" % (episode[DVDSEASON], int(episode[DVDEPISODE]))
    indices = [i for i, x in enumerate(videos) if re.search(guess, x)]
  if len(indices):
    return videos[indices[0]]
  return None  
  
def findEpisode(epid):
  if type(epid) is int:
    return dvdorder[epid]

  episode = None
  epcount = 0
  dvdnum = re.split(" *x *", epid)
  dvdseason = int(re.sub("[^0-9]*", "", dvdnum[0]));
  dvdepisode = int(re.sub("[^0-9]*", "", dvdnum[1]));
  for row in dvdorder:
    if dvdseason == row[DVDSEASON] and dvdepisode == int(row[DVDEPISODE]):
      if not episode:
        episode = []
      episode.append(row)
      epcount += 1
  if epcount == 1:
    episode = episode[0]
  return episode

# FIXME - make finding the file as smart as tvrenamer.pl
def renameVid(episode, filename=None):
  epinfo = episode
  if isinstance(episode[0], list):
    epinfo = episode[0]
    
  epid = epinfo[EPID]
  if args.dvdorder:
    epid = formatEpisodeID(epinfo[DVDSEASON], int(epinfo[DVDEPISODE]))
  if not filename:
    filename = findVideo(episode)

  if filename:
    video, ext = os.path.splitext(filename)

    if epinfo == episode:
      title = re.sub("[:/]", "-", re.sub("[.!?]+$", "", epinfo[TITLE]))
    else:
      title = ""
      for ep in episode:
        if len(title):
          title += " / "
        title += ep[TITLE]
    title = re.sub("[:/]", "-", re.sub("[.!?]+$", "", title))
    
    if args.dvdorder:
      part = int((epinfo[DVDEPISODE] * 10) % 10)
      if part and title.endswith(" (" + str(part) + ")"):
        title = title[:-4]
    eptitle = "%s %s%s" % (epid, title, ext)
    if filename != eptitle:
      if not os.path.isfile(eptitle) or args.dryrun:
        if not args.dryrun:
          os.rename(filename, eptitle)
        print filename + " to " + eptitle
      else:
        print "Already exists! " + eptitle
  return filename

def isint(s):
  try:
    int(s)
    return True
  except ValueError:
    return False
          
series = []

if os.path.isfile(args.series):
  f = open(args.series, 'rU')
  try:
    reader = csv.reader(f)
    for row in reader:
      epnum = re.split(" *x *", row[CSV_EPISODE])
      dvdep = row[CSV_DVDEP]
      if not re.match(".*x.*", dvdep):
        dvdep = row[CSV_EPISODE] + "." + dvdep
      dvdnum = re.split(" *x *", dvdep)
      epid = epnum[0] + "x" + epnum[1].zfill(2)
      info = [epid, int(dvdnum[0]), float(dvdnum[1]), row[CSV_TITLE], row[CSV_ORIGDATE]]
      series.append(info)
  finally:
    f.close()

else:
  t = tvdb_api.Tvdb()
  show = t[args.series]

  for season in show:
    for epnum in show[season]:
      episode = show[season][epnum]
      epid = episode['seasonnumber'] + "x" + episode['episodenumber'].zfill(2)
      epinfo = None
      if args.airedorder:
        epinfo = [epid, int(episode['seasonnumber']), float(episode['episodenumber'])]
      elif not args.dvdignore and episode[TVDB_DVDSEASON] and episode[TVDB_DVDEPNUM]:
        epinfo = [epid, int(episode[TVDB_DVDSEASON]), float(episode[TVDB_DVDEPNUM])]
      elif not args.dvdignore and episode[TVDB_DVDEPNUM]:
        epinfo = [epid, int(episode['seasonnumber']), float(episode[TVDB_DVDEPNUM])]
      else:
        if args.dvdmissing or args.dvdignore:
          epinfo = [epid, int(episode['seasonnumber']), float(episode['episodenumber'])]
        elif not args.quiet:
          print "No DVD info for"
          print episode
      if epinfo:
        epinfo.extend([episode['episodename'], episode['firstaired'],
                      episode['productioncode']])
        series.append(epinfo)

dvdorder = sorted(series, key=itemgetter(1, 2))

videos = [file for file in glob.glob(args.glob)]
videos.sort()

minsize = 0
if args.minsize:
  val = re.sub("^( *[0-9]+).*", "\\1", args.minsize)
  minsize = int(val)
  suffix = args.minsize[-1]
  try:
    magnitude = ["B", "K", "M", "G"].index(suffix.upper())
  except ValueError:
    magnitude = -1
  if magnitude >= 0:
    minsize *= math.pow(1024, magnitude)

if args.csv:
  csvdata = []
  for row in dvdorder:
    info = [row[EPID], "%ix%04.1f" % (row[DVDSEASON], row[DVDEPISODE]), row[ORIGDATE], row[TITLE]]
    csvdata.append(info)

  a = csv.writer(sys.stdout)
  a.writerows(csvdata)
elif args.rename:
  epnum = 0

  if isint(args.first):
    first = int(args.first)
  else:
    episode = findEpisode(args.first)
    first = dvdorder.index(episode) + 1
    
  for filename in videos:
    if minsize:
      size = os.path.getsize(filename)
      if size < minsize:
        continue
      
    video, ext = os.path.splitext(filename)
    epid = video
    if args.enumerate:
      epid = epnum + first - 1
    episode = findEpisode(epid)
    if episode:
      filename = renameVid(episode, filename=filename)
    epnum += 1
else:
  for row in dvdorder:
    print dvdorder.index(row) + 1,
    for info in row:
      print info,
    print
