#!/usr/bin/env python
#
# Copyright 2016 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import os
import datetime
import sys
from operator import itemgetter
import re
import argparse
import glob
import math
import tvdb_api
import csv

EP_ID = 0
EP_SEASON = 1
EP_NUM = 2
EP_DVDSEASON = 3
EP_DVDEPISODE = 4
EP_TITLE = 5
EP_ORIGDATE = 6

SEG_POS = 0
SEG_LEN = 1
SEG_TYPE = 2
SEG_BLACK = 3
SEG_SILENCE = 4
SEG_FLAGS = 5
SEG_CHAP = 6

SFLAG_CHAP = 1
SFLAG_NOSIL = 2

CSV_EPISODE = 0
CSV_DVDEP = 1
CSV_ORIGDATE = 2
CSV_TITLE = 3

MARGIN = 5

TYPE_TITLE = "Title"
TYPE_CREDITS = "Credits"
TYPE_QUICKIE = "Quickie"
TYPE_SHORT = "Short"
TYPE_PREV = "Prev"
TYPE_NEXT = "Next"

ftr = [3600,60,1]

parser = argparse.ArgumentParser()
parser.add_argument("series", help="Name of series on thetvdb.com")
parser.add_argument("files", nargs="*", help="examine only these files")
parser.add_argument("--quickies", default="18-56", help="range of quickie length")
parser.add_argument("--minlength", default=320, help="minimum short length")
parser.add_argument("--titlelen", help="length in seconds of opening titles", default=60)
parser.add_argument("--creditlen", help="length in seconds of end credits", default=35)
parser.add_argument("--dvdmissing", action="store_true", help="use episode data when dvd info is missing")
parser.add_argument("--quiet", action="store_true", help="don't print errors about missing DVD info")
parser.add_argument("--split", action="store_true", help="Split and rename instead of printing")
parser.add_argument("--notranscode", action="store_true", help="Split video without transcoding")
parser.add_argument("--debug", action="store_true", help="Turn on debug output")
args = parser.parse_args()

def findBlack(filename):
  video, ext = os.path.splitext(filename)
  if not os.path.exists("%s.split" % video):
    print "Finding black"
    os.system("find-black --duration 0.1 %s %s.split > /dev/null" % (filename, video))

def findSilence(filename):
  video, ext = os.path.splitext(filename)
  if not os.path.exists("%s.sil" % video):
    print "Finding silence"
    os.system("find-silence --threshold 40 --duration 0.1 %s %s.sil > /dev/null" % (filename, video))

def bestSilence(best, filename):
  video, ext = os.path.splitext(filename)

  bestsil = None
  with open(video + ".sil") as f:
    for line in f:
      info = line.split()
      begin = float(info[1])
      end = float(info[2])
      center = begin + (end - begin) / 2
      diff = abs(center - best[0])
      if ((begin >= best[1] and begin <= best[2]) or (end >= best[1] and end <= best[2]) or \
            (best[1] >= begin and best[1] <= end) or (best[2] >= begin and best[2] <= end)) \
            and (not bestsil or diff < bestsil[0]):
        bestsil = [diff, center, begin, end]

  if bestsil:
    begin = bestsil[2]
    if begin < best[1]:
      begin = best[1]
    end = bestsil[3]
    if end > best[2]:
      end = best[2]
    return [begin, end]

  return None

def segmentRow(position, length, segType=None, segBlack=None, segSilence=None, segFlags=None, segChap=None):
  if not segSilence:
    if not segFlags:
      segFlags = 0
    segFlags |= SFLAG_NOSIL
  return [position, length, segType, segBlack, segSilence, segFlags, segChap]

def loadSplits(filename):
  video, ext = os.path.splitext(filename)
  splits = [segmentRow(0.0, None)]
  with open(video + ".split") as f:
    for line in f:
      info = line.split()
      begin = float(info[1])
      end = float(info[2])
      center = begin + (end - begin) / 2
      sil = bestSilence([center, begin, end], filename)
      if sil:
        sbegin = begin if begin > sil[0] else sil[0]
        send = end if end > sil[1] else sil[1]
        pos = sbegin + (send - sbegin) / 2
      else:
        pos = -center
      splits.append(segmentRow(pos, None, segBlack=[begin, end], segSilence=sil))

  splits.append(segmentRow(vlen, 0))

  for i in range(len(splits) - 1):
    cc = splits[i][SEG_POS]
    cn = splits[i+1][SEG_POS]
    splits[i][SEG_LEN] = abs(cn) - abs(cc)
    chap = nearestChapter(abs(cc))
    if chap and abs(chap - abs(cc)) < 2:
      sflags = splits[i][SEG_FLAGS]
      if not sflags:
        sflags = 0
      sflags |= SFLAG_CHAP
      splits[i][SEG_FLAGS] = sflags
      splits[i][SEG_CHAP] = chap
  
  return splits

# FIXME - make this an option, numbering may not match anything
# depending on how DVD chapters were split
def guessEpisode(filename):
  m = re.search("([0-9]+)x([0-9]+)", filename)
  if not m:
    m = re.search("[Ss]([0-9]+)[Ee]([0-9]+)", filename)
  if m:
    sn = int(m.group(1))
    ep = int(m.group(2))
    for row in episodes:
      if sn == row[EP_DVDSEASON] and ep == int(row[EP_DVDEPISODE]):
        return row
  return None

def getShortTotal(segment):
  ci = segments.index(segment)
  slen = 0
  for segment in segments[ci:len(segments) - 1]:
    if segment[SEG_TYPE]:
      break
    slen += segment[SEG_LEN]
  return slen

def shortTooShort(segment):
  if segment[SEG_TYPE] == TYPE_SHORT and segment[SEG_LEN] < args.minlength:
    ci = newc.index(segment)
    prevs = newc[ci - 1]
    nexts = newc[ci + 1]
    if args.debug:
      print "TOO SHORT", segment, prevs, nexts
    if prevs[SEG_TYPE] != TYPE_QUICKIE or nexts[SEG_TYPE] == TYPE_CREDITS:
      prevs[SEG_LEN] += segment[SEG_LEN]
      prevs[SEG_TYPE] = segment[SEG_TYPE]
    else:
      nexts[SEG_POS] = segment[SEG_POS]
      nexts[SEG_LEN] += segment[SEG_LEN]
      nexts[SEG_TYPE] = segment[SEG_TYPE]
    return True
  return False

def loadChapters(filename):
  chap = 0
  chapters = []
  with os.popen("ffmpeg -i \"" + filename + "\" -f ffmetadata 2>&1 | grep 'Chapter #'") as f:
    for line in f:
      seconds = float(re.sub(",", "", line.split()[3]))
      chapters.append(seconds)
      chap += 1
      if not args.split:
        print "# Chapter %i: %s %f" % (chap, datetime.timedelta(seconds = seconds), seconds)
  return chapters

def nearestChapter(position):
  for chap in chapters:
    if abs(position - chap) < 10:
      return chap
  return None

def segmentLength(seg, segments):
  slen = seg[SEG_LEN]
  si = segments.index(seg) + 1
  while si < len(segments) and segments[si][SEG_TYPE] == TYPE_PREV:
    slen += segments[si][SEG_LEN]
    si += 1
  return slen

def findPrevious(seg, segments):
  si = segments.index(seg)
  while si > 0:
    if segments[si - 1][SEG_TYPE] != TYPE_PREV:
      return segments[si - 1]
    si -= 1
  return None

def findNext(seg, segments):
  si = segments.index(seg)
  while si < len(segments) - 1:
    stype = segments[si + 1][SEG_TYPE]
    if stype != TYPE_PREV and stype != TYPE_CREDITS:
      return segments[si + 1]
    si += 1
  return None

def printSegments(segments):
  for segment in segments:
    nf = len(segment)
    pos = segment[SEG_POS]
    slen = segment[SEG_LEN]
    stype = segment[SEG_TYPE]
    sblack = segment[SEG_BLACK]
    ssil = segment[SEG_SILENCE]
    sflags = segment[SEG_FLAGS]
    schap = segment[SEG_CHAP]

    if pos < 0:
      sys.stdout.write("-")
    else:
      sys.stdout.write(" ")

    if stype:
      sys.stdout.write(stype[0])
    else:
      sys.stdout.write(" ")

    sys.stdout.write(": %9.4f %9.4f" % (abs(pos), slen))
    if stype == TYPE_SHORT or stype == TYPE_QUICKIE:
      sys.stdout.write(" %9.4f" % segmentLength(segment, segments))
    else:
      sys.stdout.write("          ")
    
    if schap:
      sys.stdout.write(" %9.4f" % schap)
    else:
      sys.stdout.write("          ")

    # sys.stdout.write("  ")
    # if sflags and sflags & SFLAG_CHAP:
    #   sys.stdout.write("c")
    # else:
    #   sys.stdout.write("-")
    # if sflags and sflags & SFLAG_NOSIL:
    #   sys.stdout.write("s")
    # else:
    #   sys.stdout.write("-")

    sys.stdout.write("  ")
    sys.stdout.write(str(sblack))
    sys.stdout.write("  ")
    sys.stdout.write(str(ssil))
    sys.stdout.write("\n")

  sys.stdout.write("\n")
  sys.stdout.flush()

quickies = []
if re.match("^[-+]?[0-9]+(\.[0-9]+)?$", args.quickies):
  quickies.append(int(args.quickies))
  quickies.append(quickies[0])
elif re.match("^[0-9]+(.[0-9]+)?-[0-9]+(\.[0-9]+)?$", args.quickies):
  times = args.quickies.split("-")
  quickies.append(int(times[0]))
  quickies.append(int(times[1]))

args.titlelen = float(args.titlelen)
args.creditlen = float(args.creditlen)
args.minlength = float(args.minlength)
  
episodes = []
if os.path.isfile(args.series):
  f = open(args.series, 'rU')
  try:
    reader = csv.reader(f)
    for row in reader:
      epnum = re.split(" *x *", row[CSV_EPISODE])
      dvdnum = re.split(" *x *", row[CSV_DVDEP])
      epid = epnum[0] + "x" + epnum[1].zfill(2)
      info = [epid, int(epnum[0]), int(epnum[1]), int(dvdnum[0]), float(dvdnum[1]), \
                row[CSV_TITLE], row[CSV_ORIGDATE]]
      episodes.append(info)
  finally:
    f.close()

else:
  t = tvdb_api.Tvdb()
  show = t[args.series]
  for season in show:
    for epnum in show[season]:
      episode = show[season][epnum]
      epid = episode['seasonnumber'] + "x" + episode['episodenumber'].zfill(2)
      if episode['dvd_season'] and episode['dvd_episodenumber']:
        info = [epid, int(episode['seasonnumber']), int(episode['episodenumber']), \
                  int(episode['dvd_season']), float(episode['dvd_episodenumber']), \
                  episode['episodename'], episode['firstaired']]
        episodes.append(info)
      elif not args.quiet:
        print "No DVD info for"
        print episode
        if args.dvdmissing:
          info = [epid, int(episode['seasonnumber']), int(episode['episodenumber']), \
                    int(episode['seasonnumber']), float(episode['episodenumber']), \
                    episode['episodename'], episode['firstaired']]
          episodes.append(info)
episodes = sorted(episodes, key=itemgetter(EP_DVDSEASON, EP_DVDEPISODE))

if args.files:
  videos = args.files
else:
  videos = [file for file in glob.glob("[0-9]x[0-9][0-9].mkv")]
  videos.sort()

transcode = "--transcode"
if args.notranscode:
  transcode = ""
  
for filename in videos:
  video, ext = os.path.splitext(filename)

  episode = guessEpisode(filename)
  epindex = episodes.index(episode)
  chapters = loadChapters(filename)

  numshorts = 0
  shortindex = epindex
  dvdep = int(episode[EP_DVDEPISODE])
  dvdep2 = int(episodes[shortindex][EP_DVDEPISODE])
  while int(episodes[shortindex][EP_DVDEPISODE]) == int(episode[EP_DVDEPISODE]):
    numshorts += 1
    shortindex += 1
    dvdep2 = int(episodes[shortindex][EP_DVDSEASON])
    
  findBlack(filename)
  findSilence(filename)

  cmd = "vidinf %s | grep ID_LENGTH | sed -e 's/ID_LENGTH=//'" % filename
  process = os.popen(cmd)
  vlen = float(process.read())
  process.close()

  segments = loadSplits(filename)

  if abs(segments[0][SEG_LEN]) < 3:
    del segments[0]
    
  while abs(segments[-1][SEG_LEN]) < args.creditlen:
    segments[-2][SEG_LEN] = abs(segments[-2][SEG_LEN]) + abs(segments[-1][SEG_LEN])
    del segments[-1]

  if segments[-1][SEG_LEN] < args.creditlen or segments[-1][SEG_LEN] - args.creditlen < 10:
    segments[-1][SEG_TYPE] = TYPE_CREDITS
  else:
    segments.append(segmentRow(vlen, 0.0, segType=TYPE_CREDITS))

  if args.debug:
    printSegments(segments)
  
  didtitle = False
  since = 0
  pos = 0
  endpos = len(segments) - 1
  while pos < endpos:
    segment = segments[pos]
    prevc = None
    if pos:
      prevc = segments[pos - 1]
    nextc = segments[pos + 1]

    clen = segment[SEG_LEN]
    qpercent = clen / quickies[0] * 100

    if clen >= quickies[0] and clen <= quickies[1] and \
          (segment[SEG_POS] > 0 or \
             ((not prevc or prevc[SEG_TYPE]) and \
                (segment[SEG_POS] > 0 or prevc[SEG_TYPE] != TYPE_QUICKIE)) or \
             segment[SEG_BLACK] > 2):
      quickie = True
      if len(chapters) and prevc and prevc[SEG_TYPE] == TYPE_QUICKIE:
        achap = nearestChapter(abs(segment[SEG_POS]))
        bchap = nearestChapter(abs(nextc[SEG_POS]))
        if not achap and not bchap:
          quickie = False
          if args.debug:
            print "FAR"
      if quickie:
        segment[SEG_TYPE] = TYPE_QUICKIE
        since = 0
        if args.debug:
          print "QUICKIE", segment
        if prevc and prevc[SEG_TYPE] == TYPE_QUICKIE:
          chap = nearestChapter(abs(prevc[SEG_POS]))
          if chap and abs(chap - prevc[SEG_POS]) < abs(chap - segment[SEG_POS]):
            segment[SEG_TYPE] = None
          else:
            prevc[SEG_TYPE] = None
    elif abs(clen - args.titlelen) < MARGIN and not didtitle:
      segment[SEG_TYPE] = TYPE_TITLE
      since = 0
      didtitle = True
    elif clen < quickies[0] and segment[SEG_POS] > 0 and nextc[SEG_POS] < 0 and \
          clen + nextc[SEG_LEN] >= quickies[0] and clen + nextc[SEG_LEN] <= quickies[1] and \
          qpercent > 50 and (not prevc or prevc[SEG_TYPE] != TYPE_QUICKIE):
      if args.debug:
        print "JOIN", qpercent, clen, segment, nextc
      nextc[SEG_TYPE] = TYPE_PREV
      since = 0
      del segments[pos + 1]
      endpos -= 1
      clen += nextc[SEG_LEN]
      pos += 1
      nextc = segments[pos]
      while clen > quickies[0] and nextc[SEG_BLACK] < 0.6 and \
            clen + nextc[SEG_LEN] < quickies[1] and nextc[SEG_POS] < 0:
        if args.debug:
          print "DOUBLE JOIN", qpercent, clen, segment, nextc
        nextc[SEG_TYPE] = TYPE_PREV
        clen += nextc[SEG_LEN]
        pos += 1
        nextc = segments[pos]
    else:
      since += clen
    pos += 1

  # for seg in segments:
  #   pos = abs(seg[SEG_POS])
  #   chap = nearestChapter(pos)
  #   if chap and abs(pos - chap) < 2 and not seg[SEG_TYPE]:
  #     seg[SEG_TYPE] = TYPE_SHORT
    
  if args.debug:
    print
    printSegments(segments)

  slen = 0
  for segment in segments:
    if not segment[SEG_TYPE]:
      slen += abs(segment[SEG_LEN])
  slen = slen / numshorts
  if args.debug:
    print "Average short len:", slen
  
  clen = 0
  for curc in segments:
    pos = segments.index(curc)
    prevc = None
    if pos:
      prevc = segments[pos - 1]
    nextc = None
    if pos < len(segments) - 1:
      nextc = segments[pos + 1]
    if not curc[SEG_TYPE]:
      if not prevc or prevc[SEG_TYPE] == TYPE_QUICKIE or prevc[SEG_TYPE] == TYPE_TITLE:
        curc[SEG_TYPE] = TYPE_SHORT
        clen = curc[SEG_LEN]
        print "SHORT", curc
      else:
        curc[SEG_TYPE] = TYPE_PREV
        clen += curc[SEG_LEN]
        overpercent = (clen + abs(curc[SEG_LEN]) - slen) / curc[SEG_LEN] * 100
        if overpercent > 50 and not nextc[SEG_SILENCE]:
          curc[SEG_TYPE] = TYPE_SHORT
          clen = curc[SEG_LEN]
          if args.debug:
            print "OVER", overpercent, curc[SEG_POS], nextc[SEG_POS]
          continue

        underpercent = (slen - clen) / slen * 100
        black = curc[SEG_BLACK][1] - curc[SEG_BLACK][0]
        if (clen > slen and (overpercent > 110 or curc[SEG_POS] > 0 or black > 1.5)) or \
              (not nextc[SEG_TYPE] and clen > args.minlength and \
                           clen + nextc[SEG_LEN] > slen and nextc[SEG_POS] > 0) or \
              (nextc[SEG_POS] > 0 and underpercent > 0 and underpercent < 8 and \
                 clen + nextc[SEG_LEN] < slen):
          curc[SEG_TYPE] = TYPE_SHORT
          if args.debug:
            print "END", clen, slen, curc[SEG_POS], nextc[SEG_POS], underpercent, overpercent, black
          clen = curc[SEG_LEN]

  for segment in segments:
    if segment[SEG_CHAP] and \
          segment[SEG_TYPE] != TYPE_SHORT and segment[SEG_TYPE] != TYPE_QUICKIE:
      nextc = findNext(segment, segments)
      if nextc[SEG_TYPE] != TYPE_SHORT:
        print "NOSHORT", segment, nextc
        segment[SEG_TYPE] = TYPE_SHORT
      
  if args.debug:
    print
    printSegments(segments)
    
  i = 0
  while i < len(segments) - 1:
    segment = segments[i]
    if segment[SEG_TYPE] == TYPE_SHORT:
      slen = segmentLength(segment, segments)
      if slen < args.minlength:
        if args.debug:
          print "TOO SHORT", segment, prevc, nextc
        prevc = findPrevious(segment, segments)
        print "PREV", prevc
        if prevc[SEG_TYPE] != TYPE_SHORT:
          nextc = findNext(segment, segments)
          print "NEXT", nextc
          if nextc:
            nextc[SEG_TYPE] = TYPE_PREV
          else:
            prevc[SEG_TYPE] = TYPE_SHORT
            segment[SEG_TYPE] = TYPE_PREV
            i = segments.index(prevc)
          i -= 1
        else:
          segment[SEG_TYPE] = TYPE_PREV
    i += 1

  if args.debug:
    print
    printSegments(segments)
    
  # pos = 0
  # endpos = len(newc)
  # while pos < endpos:
  #   if shortTooShort(newc[pos]):
  #     del newc[pos]
  #     endpos -= 1
  #   else:
  #     pos += 1
  
  segments.append(segmentRow(vlen, 0.0))

  # for seg in segments:
  #   pos = abs(seg[SEG_POS])
  #   chap = nearestChapter(pos)
  #   if chap:
  #     if pos > chap and pos - chap < 2:
  #       print "# Warning: best found split %s was after chapter %s" \
  #           % (datetime.timedelta(seconds = pos), datetime.timedelta(seconds = chap))
  #       pos = chap
  #     elif chap - pos < 8:
  #       print "# Warning: best found split %s preceeded chapter %s" \
  #           % (datetime.timedelta(seconds = pos), datetime.timedelta(seconds = chap))
  #       pos = chap
  #     seg[SEG_POS] = pos
    
  quickie = 0
  epnum = 0
  for current in segments[:-1]:
    ctype = current[SEG_TYPE]
    if ctype == TYPE_QUICKIE:
      quickie += 1
      title = "Quickie %i" % quickie
      ep = episodes[epindex + epnum]
      eptitle = "%s.%i %s%s" % (video, quickie + epnum, title, ext)
    elif ctype == TYPE_SHORT:
      ep = episodes[epindex + epnum]
      title = re.sub("[:/]", "-", re.sub("[.!?]$", "", ep[EP_TITLE]))
      eptitle = "%s.%i %s%s" % (video, quickie + epnum + 1, title, ext)
#      eptitle = "%s %s%s" % (episode[EP_ID], title, ext)
      epnum += 1

    begin = abs(current[SEG_POS])
    end = begin + segmentLength(current, segments)
    if current[SEG_CHAP]:
      begin = current[SEG_CHAP]
    
    if args.split:
      if ctype == TYPE_QUICKIE or ctype == TYPE_SHORT:
        temp = video + "_tmp" + ext
        cmd = "split-video %s --output \"%s\" \"%s\" %f-%f" % (transcode, temp, filename, begin, end)
        print cmd
        os.system(cmd)
        cmd = "adjust-volume \"%s\" \"%s\" > /dev/null 2>&1" % (temp, eptitle)
        print cmd
        os.system(cmd)
        os.remove(temp)        
    elif ctype != TYPE_PREV:
      print "# " + ctype, end - begin
      if ctype == TYPE_SHORT or ctype == TYPE_QUICKIE:
        print "# " + title
      print begin

  if epnum != numshorts:
    print "# WRONG number of shorts:", epnum, numshorts
