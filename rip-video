#!/usr/bin/env python3
# -*- python -*-
#
# Copyright 2018 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import sys
import os
import argparse
from termcolor import colored
import time

sys.path.append(os.path.dirname(os.path.realpath(__file__)))
from viddin import viddin

def build_argparser():
  parser = argparse.ArgumentParser()
  parser.add_argument("source", nargs="?", help="input file")
  parser.add_argument("dest", help="output file")
  parser.add_argument("--gain", help="db to amplify or attenuate audio")
  parser.add_argument("--title", help="title number to rip")
  parser.add_argument("--chapters", help="chapters in title to rip")
  parser.add_argument("--quality", help="use this quality level when transcoding."
                      " Higher numbers are worse quality.")
  parser.add_argument("--crop", help="<top:bottom:left:right> in pixels")
  parser.add_argument("--extension", default="mkv",
                      help="extension to use for output, default is mkv")
  parser.add_argument("--cfr", action="store_true", help="constant frame rate")
  parser.add_argument("--animation", action="store_true", help="NTSC telecined animation")
  parser.add_argument("--pal-animation", action="store_true", help="PAL animation")
  parser.add_argument("--lap-animation", action="store_true",
                      help="PAL animation with bottom field first")
  parser.add_argument("--film", action="store_true", help="NTSC telecined film")
  parser.add_argument("--pal-film", action="store_true", help="PAL film")
  parser.add_argument("--tv", action="store_true",
                      help="TV content, try to detelecine and decomb")
  parser.add_argument("--tv-bob", action="store_true",
                      help="TV content, convert all fields to frames")
  parser.add_argument("--tv-bff", action="store_true", help="TV content, bottom field first")
  parser.add_argument("--tv-tff", action="store_true", help="TV content, top field first")
  parser.add_argument("--tv-bob-bff", action="store_true",
                      help="TV content, convert all fields to frames")
  parser.add_argument("--tv-bob-tff", action="store_true",
                      help="TV content, convert all fields to frames")
  parser.add_argument("--decomb", action="store_true", help="decomb interlaced content")
  parser.add_argument("--detelecine", action="store_true", help="detelecine NTSC content")
  parser.add_argument("--detelecine-bff", action="store_true",
                      help="detelecine NTSC content, bottom field first")
  parser.add_argument("--rate", help="force frame rate")
  parser.add_argument("--subtitles", action="store_true", help="include forced subtitles")
  parser.add_argument("--subtitle", help="indexes of subtitles to copy")
  parser.add_argument("--lang", help="only use subtitles in specified language")
  parser.add_argument("--audio-lang", help="only use audio tracks in specified language")
  parser.add_argument("--yprv", action="store_true", help="YPRV?")
  parser.add_argument("--ypra", action="store_true", help="YPRA?")
  parser.add_argument("--x265", action="store_true", help="encode with x265 codec")
  parser.add_argument("--anim265", action="store_true",
                      help="encode with x265 codec tuned for animation")
  parser.add_argument("--audio", help="use specified audio codec")
  parser.add_argument("--mixdown", help="mix channels into specified format")
  parser.add_argument("--width", help="output width")
  parser.add_argument("--pixel-aspect", help="output aspect ratio")
  parser.add_argument("--bluray", action="store_true", help="set defaults for ripping Blu-Ray")
  parser.add_argument("--movie", action="store_true", help="set defaults for movies")
  parser.add_argument("--restore-ntsc", action="store_true", help="slow down PAL speed-ups")
  parser.add_argument("--addsubsonly", nargs="?", type=int, default=-1,
                      help="add subtitles to existing rip")
  parser.add_argument("--normalize", action="store_true", help="normalize audio")
  parser.add_argument("--debug", action="store_true", help="print debug info")
  return parser

def uniqueFile(path, extension=None):
  dest, ext = os.path.splitext(path)
  if not extension:
    extension = ext
  if extension[0] != '.':
    extension = "." + extension
  counter = None
  upath = dest + extension
  while os.path.exists(upath):
    if not counter:
      counter = 1
    counter += 1
    upath = dest + str(counter) + "." + extension
  return upath

def printSubs(subs, lang):
  for sub in subs:
    if sub['language'] == lang:
      info = "%i:" % (sub['rv_track_id'])

      info += " Forced="
      if 'forced_track' in sub and sub['forced_track']:
        info += "Yes"
      else:
        info += "No"

      if 'uid' in sub:
        info += " UID=%i" % (sub['uid'])

      if 'language' in sub:
        slang = sub['language']
        if lang and slang != lang:
          continue
        info += " Language=%s" % (lang)

      if 'DURATION' in sub:
        info += " Duration=%s" % (sub['DURATION'])

      if 'NUMBER_OF_FRAMES' in sub:
        info += " Frames=%s" % (sub['NUMBER_OF_FRAMES'])
  
      print(info)

def outputStatus(dest, source, title, message=None, color=None, addtl=None):
  viddin.initCurses()
  status = dest + ":"
  if title:
    status += " " + title
  if message:
    status += " " + colored(message, color, attrs=["bold", "blink"])
  if addtl:
    status += " " + addtl
  # Clear to EOL at beginning and then at end in case this message wraps two lines
  status = viddin.clearEOL + status + viddin.clearEOL
  print(status)

def main():
  args = build_argparser().parse_args()

  flags = []
  encoder = "x264"
  add_subtitles = False

  if args.animation:
    flags.extend(["-r", "23.976", "--x264-tune", "animation", "--detelecine", "--decomb"])
    add_subtitles = True

  if args.pal_animation:
    flags.extend(["--x264-tune", "animation", "--decomb"])
    add_subtitles = True

  if args.lap_animation:
    flags.extend(["--x264-tune", "animation", "--deinterlace=mode=1:parity=1"])
    add_subtitles = True

  if args.film:
    flags.extend(["-r", "23.976", "--x264-tune", "film", "--detelecine", "--decomb"])
    add_subtitles = True

  if args.pal_film:
    flags.extend(["--x264-tune", "film", "--detelecine", "--decomb"])

  if args.tv:
    flags.extend(["--detelecine", "--decomb"])
    add_subtitles = True

  if args.tv_bob:
    flags.extend(["--detelecine", "--decomb=bob"])
    add_subtitles = True

  if args.tv_bff:
    flags.extend(["--detelecine=parity=1", "--decomb=parity=1"])
    add_subtitles = True

  if args.tv_tff:
    flags.extend(["--detelecine=parity=0", "--decomb=parity=0"])
    add_subtitles = True

  if args.tv_bob_bff:
  #  flags.extend(["--deinterlace=mode=15:parity=1"])
    flags.extend(["--decomb=mode=1:parity=1"])
    add_subtitles = True

  if args.tv_bob_tff:
  #  flags.extend(["--deinterlace=mode=15:parity=0"])
    flags.extend(["--decomb=mode=1:parity=0"])
    add_subtitles = True

  if args.bluray:
    flags.extend(["--aencoder", "ac3", "--mixdown", "5point1"])
    encoder = "x265"
    add_subtitles = True

  if args.movie:
    flags.extend(["-r", "23.976", "--x264-tune", "film", "--detelecine", "--decomb"])
    add_subtitles = True

  if args.decomb:
    flags.extend(["--decomb"])

  if args.detelecine:
    flags.extend(["--detelecine"])

  if args.detelecine_bff:
    flags.extend(["--detelecine=parity=1"])

  if args.rate:
    flags.extend(["-r", args.rate])

  if args.crop:
    flags.extend(["--crop", args.crop])

  if args.subtitles:
    add_subtitles = True

  if args.subtitle:
    flags.extend(["--subtitle", args.subtitle])

  if args.lang:
    flags.extend(["--native-language", args.lang, "--native-dub"])

  if args.audio_lang:
    flags.extend(["--audio-lang-list", args.audio_lang])

  if args.yprv:
    flags.extend(["-e", "x264", "-q", "27", "-x", "cabac=1:ref=5:analyse=0x133:me=umh:subme=9:chroma-me=1:deadzone-inter=21:deadzone-intra=11:b-adapt=2:rc-lookahead=60:vbv-maxrate=10000:vbv-bufsize=10000:qpmax=69:bframes=5:b-adapt=2:direct=auto:crf-max=51:weightp=2:merange=24:chroma-qp-offset=-1:sync-lookahead=2:psy-rd=1.00,0.15:trellis=2:min-keyint=23:partitions=all"])

  if args.ypra:
    flags.extend(["-E", "fdk_faac", "-B", "96k", "-6", "stereo", "-R", "44.1"])

  if args.x265:
    encoder = "x265"

  if args.anim265:
    flags.extend(["-x", "weightb=1:bframes=11:bframe-bias=90:rc-lookahead=60:me=dia:max-merge=5:rect:ctu=64:b-adapt=2:tu-inter-depth=4:tu-intra-depth=4:ipratio=0.8"])
    encoder = "x265"

  if args.audio:
    flags.extend(["--aencoder", args.audio])

  if args.mixdown:
    flags.extend(["--mixdown", args.mixdown])

  if args.width:
    flags.extend(["--w", args.width])

  if args.pixel_aspect:
    flags.extend(["--pixel-aspect", args.pixel_aspect])

  # FIXME - if user specifies a range or a list, abort
  if args.title:
    flags.extend(["--title", args.title])
    if args.source:
      source = args.source
    else:
      source = "/dev/dvd"
    dest = args.dest
  else:
    source = args.source
    dest = args.dest

  if args.chapters:
    flags.extend(["--chapters", args.chapters])

  if args.cfr or args.restore_ntsc:
    flags.extend(["--cfr"])
  elif args.animation or args.pal_animation or args.lap_animation or args.film or args.pal_film or args.tv or args.tv_bob:
    flags.extend(["--vfr"])

  if add_subtitles:
    flags.extend(["--subtitle", "scan", "--subtitle-forced"])

  if not source:
    source = dest
    dest = None

  if args.extension[0] != '.':
    args.extension = "." + args.extension
    
  if not dest:
    dest = uniqueFile(source, args.extension)

  if os.path.isdir(dest):
    base = os.path.basename(source)
    dest = os.path.join(dest, base)

  log, ext = os.path.splitext(dest)
  if len(ext) == 0:
    dest += args.extension
  log += ".log"

  encodeBegin = time.time()
  
  cmd = "HandBrakeCLI --encoder " + encoder
  cmd += " " + " ".join(flags)
  cmd += " -i \"%s\" -o \"%s\"" % (source, dest)
  cmd += " 2>\"" + log + "\""

  if args.debug:
    print(cmd)
  if args.addsubsonly == -1:
    viddin.runCommand(cmd)
    # FIXME - title might be a list or a range
    if not args.title is None and '-' in args.title:
      titles = args.title.split("-")
      olen = 0
      for t in range(int(titles[0]), int(titles[1]) + 1):
        tinfo = viddin.getTitleInfo(source, t, debugFlag=args.debug)
        if not tinfo is not None:
          print("Not found")
          exit(1)
        olen += tinfo.length
    else:
      tinfo = viddin.getTitleInfo(source, args.title, debugFlag=args.debug)
      if not tinfo is not None:
        print("Not found")
        exit(1)
      olen = tinfo.length
      tinfo.chapters.append(olen)
      if args.chapters:
        if '-' in args.chapters:
          chaps = args.chapters.split("-")
        else:
          chaps = [args.chapters, args.chapters]
        olen = tinfo.chapters[int(chaps[1])] - tinfo.chapters[int(chaps[0]) - 1]
      
    if os.path.exists(dest):
      alen = viddin.getTitleInfo(dest, debugFlag=args.debug).length
    else:
      alen = -1
    percent = abs(alen - olen) / olen
    if alen < olen and abs(alen - olen) > 0.5 and percent > 0.0014:
      outputStatus(dest, source, args.title, "FAILED TO RIP", "red",
                   "Expect %s  Got %s  Percent %.5f" %
                   (viddin.formatTimecode(olen), viddin.formatTimecode(alen), percent))
      exit(1)

    if args.normalize:
      tmp, ext = os.path.splitext(dest)
      tmp += "_aa" + ext
      cmd = "adjust-volume --volume -7 \"%s\" \"%s\"" % (dest, tmp)
      if args.debug:
        print(cmd)
      viddin.runCommand(cmd)
      os.rename(tmp, dest)

    # Keep getting titles in the mkv that are the name of the disk
    path, ext = os.path.splitext(dest)
    if ext == ".mkv":
      cmd = "mkvpropedit \"%s\" -d title" % (dest)
      if args.debug:
        print(cmd)
      viddin.runCommand(cmd)

  # FIXME - can only do subtitles on mkv dest and mkv or dvd source
  if add_subtitles or args.addsubsonly != -1:
    if os.path.isfile(dest):
      subs = viddin.getTitleInfo(dest, debugFlag=args.debug).subtitles
      if len(subs):
        cmd = "mkvpropedit \"%s\" --edit track:%i --set flag-default=1 --set flag-forced=1" % \
            (dest, int(subs[0]['rv_track_id']) + 1)
        if args.debug:
          print(cmd)
        viddin.runCommand(cmd)
    else:
      outputStatus(dest, source, args.title, "NO SUCH FILE", "red")
      exit(1)

    lang = "eng"
    if args.lang:
      lang = args.lang

    if args.title and viddin.isDVD(source):
      subs = viddin.getTitleInfo(source, int(args.title)).subtitles
      if len(subs):
        path, ext = os.path.splitext(dest)
        subtemp = path + "-subs.mkv"
        cmd = "HandBrakeCLI -w 1 --subtitle-lang-list %s --all-subtitles" \
            " -i \"%s\" --title %i -o \"%s\"" % (lang, source, int(args.title), subtemp)
        if args.chapters:
          cmd += " --chapters " + args.chapters
        if args.debug:
          print(cmd)
        viddin.runCommand(cmd)

        if not os.path.exists(subtemp):
          print("Failed to extract subtitles")
          exit(1)
        else:
          subs = viddin.getTitleInfo(subtemp).subtitles
          best = None
          for sub in subs:
            if sub['language'] == lang and sub['codec_id'] == "S_VOBSUB":
              best = sub
              break

          if best:
            tnum = int(best['rv_track_id'])
            spath = "%s_%i.idx" % (path, tnum)
            cmd = "mkvextract tracks \"%s\" %i:\"%s\"" % (subtemp, tnum, spath)
            if args.debug:
              print(cmd)
            viddin.runCommand(cmd)

            temp = uniqueFile(dest, "mkv")
            cmd = "mkvmerge -o \"%s\" \"%s\"" % (temp, dest)
            cmd += " --default-track 0:0 --forced-track 0:0 --language 0:%s -s 0 \"%s\"" \
                % (lang, spath)
            if args.debug:
              print(cmd)
            viddin.runCommand(cmd)

            os.remove(spath)
            path, ext = os.path.splitext(spath)
            os.remove(path + ".sub")
            os.rename(temp, dest)
          os.remove(subtemp)
    elif os.path.isfile(source):
      subs = viddin.getTitleInfo(source).subtitles
      if len(subs):
        path, ext = os.path.splitext(dest)
        spaths = []
        longest = None

        if args.addsubsonly is None or args.addsubsonly == -1:
          longest_len = None
          subcount = 0
          for sub in subs:
            if sub['language'] == lang:
              subcount += 1
              sublen = viddin.decodeTimecode(sub['DURATION'])
              if 'NUMBER_OF_FRAMES' in sub \
                  and (not longest or (sublen - longest_len) / longest_len > 0.10):
                if longest_len:
                  print(sublen, longest_len, (sublen - longest_len) / longest_len)
                longest = sub
                longest_len = sublen

          if subcount > 1:
            outputStatus(dest, source, args.title, "WARNING", "yellow",
                         "multiple matching subtitles. using %i" % (longest['rv_track_id']))
            printSubs(subs, lang)
        else:
          for sub in subs:
            if args.addsubsonly == int(sub['rv_track_id']):
              longest = sub
              break

        if longest:
          sub_source = source

          # If chapters were specified, the original file has to be
          # split just to split the subs, otherwise the subs will be
          # misaligned.

          if args.chapters:
            ts_path, ext = os.path.splitext(path)
            ts_path += ".mkv"
            sub_source = uniqueFile(ts_path)

            if '-' in args.chapters:
              chaps = args.chapters.split("-")
            else:
              chaps = [args.chapters, args.chapters]
            chaptimes = viddin.loadChapters(source)
            chaptimes.append(viddin.getTitleInfo(source, debugFlag=args.debug).length)
            start = chaptimes[int(chaps[0]) - 1]
            end = chaptimes[int(chaps[1])]
            cmd = "mkvmerge --split parts:%s-%s -o \"%s\" \"%s\"" % \
                (viddin.formatTimecode(start), viddin.formatTimecode(end), sub_source, source)
            if args.debug:
              print(cmd)
            viddin.runCommand(cmd)

          tnum = int(longest['rv_track_id'])
          spath = "%s_%i.sub" % (path, tnum)
          cmd = "mkvextract tracks \"%s\" %i:\"%s\"" % (sub_source, tnum, spath)
          if args.debug:
            print(cmd)
          viddin.runCommand(cmd)
          spath2 = "%s_%i.idx" % (path, tnum)
          if os.path.exists(spath2):
            spath = spath2
          spaths.append(spath)
          if sub_source != source:
            os.remove(sub_source)

        temp = uniqueFile(dest)
        cmd = "mkvmerge -o \"%s\" \"%s\"" % (temp, dest)
        for p in spaths:
          cmd += " --default-track 0:0 --forced-track 0:0 --language 0:%s \"%s\"" % (lang, p)
        if args.debug:
          print(cmd)
        viddin.runCommand(cmd)

        for p in spaths:
          os.remove(p)
          p2, ext = os.path.splitext(p)
          p2 += ".sub"
          if os.path.exists(p2):
            os.remove(p2)
        os.rename(temp, dest)

  if args.restore_ntsc and os.path.exists(dest):
    cmd = "restore-ntsc \"%s\"" % (dest)
    if args.debug:
      print(cmd)
    viddin.runCommand(cmd)
    path, ext = os.path.splitext(dest)
    os.rename(path + "-NTSC" + ext, dest)

  sys.stdout.flush()
  alen = viddin.getTitleInfo(dest, debugFlag=args.debug).length

  encodeEnd = time.time()
  
  outputStatus(dest, source, args.title,
               addtl=str(viddin.formatTimecode(alen)) + "  rip: "
               + str(viddin.formatTimecode(encodeEnd - encodeBegin)))

  return

if __name__ == '__main__':
  exit(main() or 0)
