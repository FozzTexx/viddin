#!/usr/bin/env python3
# -*- python -*-
#
# Copyright 2018 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import os
import sys
import argparse
import json
import xmltodict
import re
from termcolor import colored
import subprocess
import pty
import datetime
import curses

encoder = "x264"
add_subtitles = False

parser = argparse.ArgumentParser()
parser.add_argument("source", nargs="?", help="input file")
parser.add_argument("dest", help="output file")
parser.add_argument("--gain", help="db to amplify or attenuate audio")
parser.add_argument("--title", help="title number to rip")
parser.add_argument("--chapters", help="chapters in title to rip")
parser.add_argument("--quality", help="use this quality level when transcoding. Higher numbers are worse quality.")
parser.add_argument("--crop", help="<top:bottom:left:right> in pixels")
parser.add_argument("--extension", default="mkv", help="extension to use for output, default is mkv")
parser.add_argument("--cfr", action="store_true", help="constant frame rate")
parser.add_argument("--animation", action="store_true", help="NTSC telecined animation")
parser.add_argument("--pal-animation", action="store_true", help="PAL animation")
parser.add_argument("--lap-animation", action="store_true", help="PAL animation with bottom field first")
parser.add_argument("--film", action="store_true", help="NTSC telecined film")
parser.add_argument("--pal-film", action="store_true", help="PAL film")
parser.add_argument("--tv", action="store_true", help="TV content, try to detelecine and decomb")
parser.add_argument("--tv-bob", action="store_true", help="TV content, convert all fields to frames")
parser.add_argument("--tv-bff", action="store_true", help="TV content, bottom field first")
parser.add_argument("--tv-tff", action="store_true", help="TV content, top field first")
parser.add_argument("--tv-bob-bff", action="store_true", help="TV content, convert all fields to frames")
parser.add_argument("--tv-bob-tff", action="store_true", help="TV content, convert all fields to frames")
parser.add_argument("--decomb", action="store_true", help="decomb interlaced content")
parser.add_argument("--detelecine", action="store_true", help="detelecine NTSC content")
parser.add_argument("--detelecine-bff", action="store_true", help="detelecine NTSC content, bottom field first")
parser.add_argument("--rate", help="force frame rate")
parser.add_argument("--subtitles", action="store_true", help="include forced subtitles")
parser.add_argument("--subtitle", help="indexes of subtitles to copy")
parser.add_argument("--lang", help="only use subtitles in specified language")
parser.add_argument("--audio-lang", help="only use audio tracks in specified language")
parser.add_argument("--yprv", action="store_true", help="YPRV?")
parser.add_argument("--ypra", action="store_true", help="YPRA?")
parser.add_argument("--x265", action="store_true", help="encode with x265 codec")
parser.add_argument("--anim265", action="store_true", help="encode with x265 codec tuned for animation")
parser.add_argument("--audio", help="use specified audio codec")
parser.add_argument("--mixdown", help="mix channels into specified format")
parser.add_argument("--width", help="output width")
parser.add_argument("--pixel-aspect", help="output aspect ratio")
parser.add_argument("--bluray", action="store_true", help="set defaults for ripping Blu-Ray")
parser.add_argument("--movie", action="store_true", help="set defaults for movies")
parser.add_argument("--restore-ntsc", action="store_true", help="slow down PAL speed-ups")
parser.add_argument("--addsubsonly", action="store_true", help="slow down PAL speed-ups")
parser.add_argument("--normalize", action="store_true", help="normalize audio")
parser.add_argument("--debug", action="store_true", help="print debug info")
args = parser.parse_args()

def subWithUid(uid, subs):
  for track in subs:
    if 'uid' in track and uid == track['uid']:
      return track
  return None

def getSubs(path, title=None):
  subs = []
  _, ext = os.path.splitext(path)
  if title != None:
    cmd = "lsdvd -t %i -s \"%s\"" % (int(args.title), path)
    if args.debug:
      print(cmd)
    else:
      cmd += " 2>/dev/null"
    with os.popen(cmd) as f:
      for line in f:
        fields = line.split()
        if len(fields) and fields[0] == "Subtitle:":
          key = None
          val = None
          end = False
          values = {}
          for field in fields[2:]:
            if field[-1] == ':':
              key = field[:-1]
            else:
              if field[-1] == ',':
                end = True
                field = field[:-1]
              if not val:
                val = field
              else:
                if not isinstance(val, list):
                  val = [val]
                val.append(field)
            if end:
              values[key] = val
              end = False
              key = None
              val = None
          subs.append(values)
  elif ext == ".mkv":
    cmd = "mkvmerge -i -F json \"%s\"" % (path)
    if args.debug:
      print(cmd)
    process = os.popen(cmd)
    jstr = process.read()
    process.close()
    jinfo = json.loads(jstr)

    for track in jinfo['tracks']:
      if track['type'] == "subtitles":
        info = {}
        info['rv_track_id'] = track['id'] 
        info.update(track['properties'])
        subs.append(info)

    cmd = "mkvextract tags \"%s\"" % (path)
    if args.debug:
      print(cmd)
    process = os.popen(cmd)
    xstr = process.read()
    process.close()
    xstr = xstr.strip()
    if len(xstr):
      xinfo = xmltodict.parse(xstr)['Tags']
      xlist = []
      for track in xinfo:
        xi1 = xinfo[track]
        for xi2 in xi1:
          xdict = {}
          if 'Targets' in xi2:
            xi3 = xi2['Targets']
            if xi3 and 'TrackUID' in xi3:
              xdict['TrackUID'] = int(xi3['TrackUID'])
          if 'Simple' in xi2:
            xi3 = xi2['Simple']
            if isinstance(xi3, list):
              for xi4 in xi3:
                xdict[xi4['Name']] = xi4['String']
            else:
              xdict[xi3['Name']] = xi3['String']
          xlist.append(xdict)

      for track in xlist:
        if 'TrackUID' in track:
          sub = subWithUid(track['TrackUID'], subs)
          if sub:
            sub.update(track)
    
  return subs

def getForcedSub(path):
  if os.path.exists(path):
    cmd = "grep Passthrough \"%s\" | grep subtitle" % (path)
    if args.debug:
      print(cmd)
    with os.popen(cmd) as f:
      for line in f:
        fields = line.split()
        for idx in range(len(fields) - 4):
          if fields[idx] == "(track" and fields[idx + 2] == "id":
            return int(fields[idx + 3][:-1], 0)
  return None

def uniqueFile(path):
  dest, ext = os.path.splitext(path)
  counter = None
  upath = dest + "." + args.extension
  while os.path.exists(upath):
    if not counter:
      counter = 1
    counter += 1
    upath = dest + str(counter) + "." + args.extension
  return upath

def decodeTimecode(tc):
  fraction = 0
  if re.match(".*\.[0-9]+$", tc):
    parts = re.split("\.", tc)
    fraction = float("."+parts[1])
    tc = parts[0]

  for m in re.finditer(r'[0-9]', tc):
    pass
  tc = tc[:m.end(0)]
  
  seconds = sum(float(x) * 60 ** i for i,x in enumerate(reversed(tc.split(":"))))
  seconds += fraction
  return seconds

def formatTimecode(tc):
  ft = str(datetime.timedelta(seconds = tc))
  p = re.compile(r'^[0:]+')
  m = p.search(ft)
  if m:
    ft = ft[m.span()[1]:]
  dp = ft.rfind(".")
  if dp >= 0 and dp < len(ft) - 4:
    ft = ft[:dp+4]
  return ft
  
def findLength(info):
  idx = info.index("Length:")
  return decodeTimecode(info[idx+1])

def trackWithUid(uid, tracks):
  for track in tracks:
    if 'uid' in track and uid == track['uid']:
      return track
  return None

def getLengthMKV(path):
  cmd = "mkvmerge -i -F json \"%s\"" % (path)
  if args.debug:
    print(cmd)
  process = os.popen(cmd)
  jstr = process.read()
  process.close()
  jinfo = json.loads(jstr)

  tracks = []
  for track in jinfo['tracks']:
    info = {'type': track['type']}
    info['rv_track_id'] = track['id']
    info.update(track['properties'])
    tracks.append(info)

  cmd = "mkvextract tags \"%s\"" % (path)
  if args.debug:
    print(cmd)
  process = os.popen(cmd)
  xstr = process.read()
  process.close()
  xstr = xstr.strip()
  if len(xstr):
    xinfo = xmltodict.parse(xstr)['Tags']
    xlist = []
    for track in xinfo:
      xi1 = xinfo[track]
      for xi2 in xi1:
        xdict = {}
        if 'Targets' in xi2:
          xi3 = xi2['Targets']
          if xi3 and 'TrackUID' in xi3:
            xdict['TrackUID'] = int(xi3['TrackUID'])
        if 'Simple' in xi2:
          xi3 = xi2['Simple']
          if type(xi3) == list:
            for xi4 in xi3:
              xdict[xi4['Name']] = xi4['String']
          else:
            xdict[xi3['Name']] = xi3['String']
        xlist.append(xdict)

    for track in xlist:
      if 'TrackUID' in track:
        tt = trackWithUid(track['TrackUID'], tracks)
        if tt:
          tt.update(track)

  tlen = None
  for track in tracks:
    if track['type'] == "video" and 'DURATION' in track:
      alen = decodeTimecode(track['DURATION'])
      if not tlen or alen > tlen:
        tlen = alen

  if not tlen:
    container = jinfo['container']['properties']
    if 'duration' in container:
      tlen = int(container['duration'])
      tlen /= 1000000000
  return tlen

def getLength(filename, title=None, chapters=None):
  clen = []
  if title:
    cmd = "lsdvd -t %s -c \"%s\"" % (title, filename)
    if args.debug:
      print(cmd)
    else:
      cmd += " 2>/dev/null"
    with os.popen(cmd) as f:
      lines = f.read().splitlines()
    for line in lines:
      info = line.split()
      if len(info) < 1:
        continue
      if info[0] == "Title:":
        tlen = findLength(info)
      elif info[0] == "Chapter:":
        clen.append(findLength(info))
    if chapters:
      if chapters.index("-"):
        chaps = chapters.split("-")
      else:
        chaps = [chapters, chapters]
      tlen = 0
      for c in range(int(chaps[0]), int(chaps[1]) + 1):
        tlen += clen[c]
  else:
    _, ext = os.path.splitext(filename)
    if ext == ".mkv":
      tlen = getLengthMKV(filename)
    else:
      cmd = "vidinf \"%s\" | grep ID_LENGTH | sed -e 's/ID_LENGTH=//'" % filename
      if args.debug:
        print(cmd)
      process = os.popen(cmd)
      tlen = float(process.read())
      process.close()
  return tlen
  
def printSubs(subs, lang):
  for sub in subs:
    if sub['language'] == lang:
      info = "%i:" % (sub['rv_track_id'])

      info += " Forced="
      if 'forced_track' in sub and sub['forced_track']:
        info += "Yes"
      else:
        info += "No"

      if 'uid' in sub:
        info += " UID=%i" % (sub['uid'])

      if 'language' in sub:
        lang = sub['language']
        if args.lang and lang != args.lang:
          continue
        info += " Language=%s" % (lang)

      if 'DURATION' in sub:
        info += " Duration=%s" % (sub['DURATION'])

      if 'NUMBER_OF_FRAMES' in sub:
        info += " Frames=%s" % (sub['NUMBER_OF_FRAMES'])
  
      print(info)

def outputStatus(dest, source, title, message=None, color=None, addtl=None):
  if not hasattr(outputStatus, 'didInit'):
    curses.setupterm()
    outputStatus.didInit = True
  
  status = dest + ":"
  if title:
    status += " " + title
  if message:
    status += " " + colored(message, color, attrs=["bold", "blink"])
  if addtl:
    status += " " + addtl
  # Clear to EOL at beginning and then at end in case this message wraps two lines
  status = curses.tigetstr("el").decode() + status + curses.tigetstr("el").decode()
  print(status)

def runCommand(cmd):
  master, slave = pty.openpty()
  with subprocess.Popen(cmd, shell=True, stdin=slave, stdout=slave, stderr=slave,
                       close_fds=True) as p:
    m = os.fdopen(master, 'r')
    os.close(slave)
    try:
      while True:
        c = m.read(1)
        if c == '\n':
          c = '\r'
        sys.stdout.write(c)
        sys.stdout.flush()
    except:
      pass

flags = []

if args.animation:
  flags.extend(["-r", "23.976", "--x264-tune", "animation", "--detelecine", "--decomb"])

if args.pal_animation:
  flags.extend(["--x264-tune", "animation", "--decomb"])

if args.lap_animation:
  flags.extend(["--x264-tune", "animation", "--deinterlace=mode=1:parity=1"])

if args.film:
  flags.extend(["-r", "23.976", "--x264-tune", "film", "--detelecine", "--decomb"])
  add_subtitles = True
  
if args.pal_film:
  flags.extend(["--x264-tune", "film", "--detelecine", "--decomb"])

if args.tv:
  flags.extend(["--detelecine", "--decomb"])
  add_subtitles = True
  
if args.tv_bob:
  flags.extend(["--detelecine", "--decomb=bob"])
  add_subtitles = True
  
if args.tv_bff:
  flags.extend(["--detelecine=parity=1", "--decomb=parity=1"])
  add_subtitles = True
  
if args.tv_bob_tff:
  flags.extend(["--detelecine=parity=0", "--decomb=parity=0"])
  add_subtitles = True
  
if args.tv_bob_bff:
#  flags.extend(["--deinterlace=mode=15:parity=1"])
  flags.extend(["--decomb=mode=1:parity=1"])
  add_subtitles = True
  
if args.tv_bob_tff:
#  flags.extend(["--deinterlace=mode=15:parity=0"])
  flags.extend(["--decomb=mode=1:parity=0"])
  add_subtitles = True
  
if args.bluray:
  flags.extend(["--aencoder", "ac3", "--mixdown", "5point1"])
  encoder = "x265"
  add_subtitles = True

if args.movie:
  flags.extend(["-r", "23.976", "--x264-tune", "film", "--detelecine", "--decomb"])
  add_subtitles = True

if args.decomb:
  flags.extend(["--decomb"])

if args.detelecine:
  flags.extend(["--detelecine"])

if args.detelecine_bff:
  flags.extend(["--detelecine=parity=1"])

if args.rate:
  flags.extend(["-r", args.rate])

if args.subtitles:
  add_subtitles = True

if args.subtitle:
  flags.extend(["--subtitle", args.subtitle])

if args.lang:
  flags.extend(["--native-language", args.lang, "--native-dub"])

if args.audio_lang:
  flags.extend(["--audio-lang-list", args.audio_lang])

if args.yprv:
  flags.extend(["-e", "x264", "-q", "27", "-x", "cabac=1:ref=5:analyse=0x133:me=umh:subme=9:chroma-me=1:deadzone-inter=21:deadzone-intra=11:b-adapt=2:rc-lookahead=60:vbv-maxrate=10000:vbv-bufsize=10000:qpmax=69:bframes=5:b-adapt=2:direct=auto:crf-max=51:weightp=2:merange=24:chroma-qp-offset=-1:sync-lookahead=2:psy-rd=1.00,0.15:trellis=2:min-keyint=23:partitions=all"])

if args.ypra:
  flags.extend(["-E", "fdk_faac", "-B", "96k", "-6", "stereo", "-R", "44.1"])

if args.x265:
  encoder = "x265"
  
if args.anim265:
  flags.extend(["-x", "weightb=1:bframes=11:bframe-bias=90:rc-lookahead=60:me=dia:max-merge=5:rect:ctu=64:b-adapt=2:tu-inter-depth=4:tu-intra-depth=4:ipratio=0.8"])
  encoder = "x265"

if args.audio:
  flags.extend(["--aencoder", args.audio])

if args.mixdown:
  flags.extend(["--mixdown", args.mixdown])

if args.width:
  flags.extend(["--w", args.width])

if args.pixel_aspect:
  flags.extend(["--pixel-aspect", args.pixel_aspect])

if args.title:
  flags.extend(["--title", args.title])
  if args.source:
    source = args.source
  else:
    source = "/dev/dvd"
  dest = args.dest
else:
  source = args.source
  dest = args.dest

if args.chapters:
  flags.extend(["--chapters", args.chapters])

if args.cfr or args.restore_ntsc:
  flags.extend(["--cfr"])
elif args.animation or args.pal_animation or args.lap_animation or args.film or args.pal_film or args.tv or args.tv_bob:
  flags.extend(["--vfr"])

if add_subtitles:
  flags.extend(["--subtitle", "scan", "--subtitle-forced"])

if not source:
  source = dest
  dest = None
  
if not dest:
  dest = uniqueFile(source)

if os.path.isdir(dest):
  base = os.path.basename(source)
  dest = os.path.join(dest, base)

log, ext = os.path.splitext(dest)
log += ".log"

cmd = "HandBrakeCLI --encoder " + encoder
cmd += " " + " ".join(flags)
cmd += " -i \"%s\" -o \"%s\"" % (source, dest)
cmd += " 2>\"" + log + "\""

if args.debug:
  print(cmd)
if not args.addsubsonly:
  runCommand(cmd)
  olen = getLength(source, args.title, args.chapters)
  if os.path.exists(dest):
    alen = getLength(dest)
  else:
    alen = -1
  if alen < olen:
    outputStatus(dest, source, args.title, "FAILED TO RIP", "red", str(olen) + " " + str(alen))
    sys.exit(1)

  if args.normalize:
    tmp, ext = os.path.splitext(dest)
    tmp += "_aa" + ext
    cmd = "adjust-volume --volume -8 \"%s\" \"%s\" > /dev/null 2>&1" % (dest, tmp)
    if args.debug:
      print(cmd)
    runCommand(cmd)
    os.rename(tmp, dest)

  # Keep getting titles in the mkv that are the name of the disk
  path, ext = os.path.splitext(dest)
  if ext == ".mkv":
    cmd = "mkvpropedit \"%s\" -d title" % (dest)
    if args.debug:
      print(cmd)
    else:
      cmd += " >/dev/null 2>&1"
    os.system(cmd)

if args.restore_ntsc and os.path.exists(dest):
  cmd = "restore-ntsc " + dest
  path, ext = os.path.splitext(dest)
  if args.debug:
    print(cmd)
  else:
    cmd += " >/dev/null 2>&1"
  os.system(cmd)
  os.rename(path + "-NTSC" + ext, dest)

# FIXME - can only do subtitles on mkv dest and mkv or dvd source
if add_subtitles or args.addsubsonly:
  if os.path.isfile(dest):
    subs = getSubs(dest)
    if len(subs):
      cmd = "mkvpropedit \"%s\" --edit track:%i --set flag-default=1 --set flag-forced=1" % \
          (dest, int(subs[0]['rv_track_id']) + 1)
      if args.debug:
        print(cmd)
      else:
        cmd += " >/dev/null 2>&1"
      os.system(cmd)

  lang = "eng"
  if args.lang:
    lang = args.lang
    
  if args.title:
    subs = getSubs(source, int(args.title))
    if len(subs) > 0:
      path, ext = os.path.splitext(dest)
      subtemp = path + "-subs.mkv"
      cmd = "HandBrakeCLI -w 1 --subtitle-lang-list %s --all-subtitles" \
          " -i \"%s\" --title %i -o \"%s\"" % (lang, source, int(args.title), subtemp)
      if args.debug:
        print(cmd)
      else:
        cmd += " 2>/dev/null"
      runCommand(cmd)

      if not os.path.exists(subtemp):
        print("Failed to extract subtitles")
      else:
        subs = getSubs(subtemp)
        best = None
        for sub in subs:
          if sub['language'] == lang and sub['codec_id'] == "S_VOBSUB":
            best = sub
            break

        if best:
          tnum = int(best['rv_track_id'])
          spath = "%s_%i.idx" % (path, tnum)
          cmd = "mkvextract tracks \"%s\" %i:\"%s\"" % (subtemp, tnum, spath)
          if args.debug:
            print(cmd)
          else:
            cmd += " >/dev/null 2>&1"
          os.system(cmd)

          temp = uniqueFile(dest)
          cmd = "mkvmerge -o \"%s\" \"%s\"" % (temp, dest)
          cmd += " --default-track 0:0 --forced-track 0:0 --language 0:%s -s 0 \"%s\"" \
              % (lang, spath)
          if args.debug:
            print(cmd)
          else:
            cmd += " >/dev/null 2>&1"
          os.system(cmd)

          os.remove(spath)
          path, ext = os.path.splitext(spath)
          os.remove(path + ".sub")
          os.rename(temp, dest)
        os.remove(subtemp)
  elif os.path.isfile(source):
    subs = getSubs(source)
    if len(subs):
      path, ext = os.path.splitext(dest)
      spaths = []
      longest = None
      longest_len = None
      subcount = 0
      for sub in subs:
        if sub['language'] == lang:
          subcount += 1
          sublen = decodeTimecode(sub['DURATION'])
          if 'NUMBER_OF_FRAMES' in sub \
              and (not longest or (sublen - longest_len) / longest_len > 0.10):
            if longest_len:
              print(sublen, longest_len, (sublen - longest_len) / longest_len)
            longest = sub
            longest_len = sublen

      if subcount > 1:
        outputStatus(dest, source, args.title, "WARNING", "yellow",
                     "multiple matching subtitles. using %i" % (longest['rv_track_id']))
        printSubs(subs, lang)

      if longest:
        tnum = int(longest['rv_track_id'])
        spath = "%s_%i.sub" % (path, tnum)
        cmd = "mkvextract tracks \"%s\" %i:\"%s\"" % (source, tnum, spath)
        if args.debug:
          print(cmd)
        else:
          cmd += " >/dev/null 2>&1"
        os.system(cmd)
        spath2 = "%s_%i.idx" % (path, tnum)
        if os.path.exists(spath2):
          spath = spath2
        spaths.append(spath)

      temp = uniqueFile(dest)
      cmd = "mkvmerge -o \"%s\" \"%s\"" % (temp, dest)
      for p in spaths:
        cmd += " --default-track 0:0 --forced-track 0:0 --language 0:%s \"%s\"" % (lang, p)
      if args.debug:
        print(cmd)
      else:
        cmd += " >/dev/null 2>&1"
      os.system(cmd)

      for p in spaths:
        os.remove(p)
        p2, ext = os.path.splitext(p)
        p2 += ".sub"
        if os.path.exists(p2):
          os.remove(p2)
      os.rename(temp, dest)

sys.stdout.flush()
alen = getLength(dest)
outputStatus(dest, source, args.title, addtl=str(formatTimecode(alen)))
