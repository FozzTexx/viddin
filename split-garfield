#!/usr/bin/env python
#
# Copyright 2016 by Chris Osborn <fozztexx@fozztexx.com>
#
# This file is part of viddin.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

import os
import datetime
import sys
from operator import itemgetter
import re
import argparse
import glob
import math
import tvdb_api
import csv

EP_ID = 0
EP_SEASON = 1
EP_NUM = 2
EP_DVDSEASON = 3
EP_DVDEPISODE = 4
EP_TITLE = 5
EP_ORIGDATE = 6

SEG_POS = 0
SEG_LEN = 1
SEG_TYPE = 2
SEG_BLACK = 3
SEG_SILENCE = 4
SEG_CHAP = 5
SEG_SPLEN = 6

SFLAG_CHAP = 1
SFLAG_NOSIL = 2

CSV_EPISODE = 0
CSV_DVDEP = 1
CSV_ORIGDATE = 2
CSV_TITLE = 3

MARGIN = 5

TYPE_TITLE = "Title"
TYPE_CREDITS = "Credits"
TYPE_QUICKIE = "Quickie"
TYPE_SHORT = "Short"
TYPE_PREV = "Prev"
TYPE_NEXT = "Next"

ftr = [3600,60,1]

parser = argparse.ArgumentParser()
parser.add_argument("series", help="Name of series on thetvdb.com")
parser.add_argument("files", nargs="*", help="examine only these files")
parser.add_argument("--quickies", default="18-56", help="range of quickie length")
parser.add_argument("--minlength", default=320, help="minimum short length")
parser.add_argument("--titlelen", help="length in seconds of opening titles", default=60)
parser.add_argument("--creditlen", help="length in seconds of end credits", default=35)
parser.add_argument("--dvdmissing", action="store_true", help="use episode data when dvd info is missing")
parser.add_argument("--quiet", action="store_true", help="don't print errors about missing DVD info")
parser.add_argument("--split", action="store_true", help="Split and rename instead of printing")
parser.add_argument("--notranscode", action="store_true", help="Split video without transcoding")
parser.add_argument("--debug", action="store_true", help="Turn on debug output")
args = parser.parse_args()

def findBlack(filename):
  video, ext = os.path.splitext(filename)
  if not os.path.exists("%s.split" % video):
    print "Finding black"
    os.system("find-black --duration 0.1 %s %s.split > /dev/null" % (filename, video))

def findSilence(filename):
  video, ext = os.path.splitext(filename)
  if not os.path.exists("%s.sil" % video):
    print "Finding silence"
    os.system("find-silence --threshold 40 --duration 0.1 %s %s.sil > /dev/null" % (filename, video))

def bestSilence(best, filename):
  video, ext = os.path.splitext(filename)

  bestsil = None
  with open(video + ".sil") as f:
    for line in f:
      info = line.split()
      begin = float(info[1])
      end = float(info[2])
      center = begin + (end - begin) / 2
      diff = abs(center - best[0])
      if ((begin >= best[1] and begin <= best[2]) or (end >= best[1] and end <= best[2]) or \
            (best[1] >= begin and best[1] <= end) or (best[2] >= begin and best[2] <= end)) \
            and (not bestsil or diff < bestsil[0]):
        bestsil = [diff, center, begin, end]

  if bestsil:
    begin = bestsil[2]
    if begin < best[1]:
      begin = best[1]
    end = bestsil[3]
    if end > best[2]:
      end = best[2]
    return [begin, end]

  return None

def segmentRow(position, length, segType=None, segBlack=None, segSilence=None, segChap=None):
  splen = 0.0
  if segBlack:
    sbegin = segBlack[0] if not segSilence or segBlack[0] > segSilence[0] else segSilence[0]
    send = segBlack[1] if not segSilence or segBlack[1] > segSilence[1] else segSilence[1]
    splen = send - sbegin
  return [position, length, segType, segBlack, segSilence, segChap, splen]

def loadSplits(filename):
  video, ext = os.path.splitext(filename)
  splits = [segmentRow(0.0, None)]
  with open(video + ".split") as f:
    for line in f:
      info = line.split()
      begin = float(info[1])
      end = float(info[2])
      center = begin + (end - begin) / 2
      sil = bestSilence([center, begin, end], filename)
      if sil:
        sbegin = begin if begin > sil[0] else sil[0]
        send = end if end < sil[1] else sil[1]
        pos = sbegin + (send - sbegin) / 2
      else:
        pos = -center
      splits.append(segmentRow(pos, None, segBlack=[begin, end], segSilence=sil))

  splits.append(segmentRow(vlen, 0))

  for chap in chapters:
    best = None
    for seg in splits:
      pos = abs(seg[SEG_POS])
      if not best or abs(chap - pos) < abs(chap - abs(best[SEG_POS])):
        best = seg
    if best and abs(chap - abs(best[SEG_POS])) < 10:
      best[SEG_CHAP] = chap
      
  for i in range(len(splits) - 1):
    cc = splits[i][SEG_POS]
    cn = splits[i+1][SEG_POS]
    splits[i][SEG_LEN] = abs(cn) - abs(cc)
  
  return splits

# FIXME - make this an option, numbering may not match anything
# depending on how DVD chapters were split
def guessEpisode(filename):
  m = re.search("([0-9]+)x([0-9]+)", filename)
  if not m:
    m = re.search("[Ss]([0-9]+)[Ee]([0-9]+)", filename)
  if m:
    sn = int(m.group(1))
    ep = int(m.group(2))
    for row in episodes:
      if sn == row[EP_DVDSEASON] and ep == int(row[EP_DVDEPISODE]):
        return row
  return None

def getShortTotal(segment):
  ci = segments.index(segment)
  slen = 0
  for segment in segments[ci:len(segments) - 1]:
    if segment[SEG_TYPE]:
      break
    slen += segment[SEG_LEN]
  return slen

def loadChapters(filename, vlen):
  chap = 0
  chapters = []
  with os.popen("ffmpeg -i \"" + filename + "\" -f ffmetadata 2>&1 | grep 'Chapter #'") as f:
    for line in f:
      fields = line.split()
      begin = float(re.sub(",", "", fields[3]))
      end = float(fields[5])
      if begin == 0.0 and abs(end - vlen) < 1:
        continue
      chapters.append(begin)
      chap += 1
      if not args.split:
        print "# Chapter %i: %s %f" % (chap, datetime.timedelta(seconds = begin), begin)
  return chapters

def nearestChapter(position):
  for chap in chapters:
    if abs(position - chap) < 10:
      return chap
  return None

def segmentLength(seg, segments):
  si = segments.index(seg) + 1
  while si < len(segments) and segments[si][SEG_TYPE] == TYPE_PREV:
    si += 1
  return abs(segments[si][SEG_POS]) - abs(seg[SEG_POS])

def findPrevious(seg, segments):
  si = segments.index(seg)
  while si > 0:
    if segments[si - 1][SEG_TYPE] != TYPE_PREV:
      return segments[si - 1]
    si -= 1
  return None

def findNext(seg, segments):
  si = segments.index(seg)
  while si < len(segments) - 1:
    stype = segments[si + 1][SEG_TYPE]
    if stype != TYPE_PREV and stype != TYPE_CREDITS:
      return segments[si + 1]
    si += 1
  return None

def printSegments(segments):
  for segment in segments:
    nf = len(segment)
    pos = segment[SEG_POS]
    slen = segment[SEG_LEN]
    stype = segment[SEG_TYPE]
    sblack = segment[SEG_BLACK]
    ssil = segment[SEG_SILENCE]
    schap = segment[SEG_CHAP]
    splen = segment[SEG_SPLEN]

    if pos < 0:
      sys.stdout.write("-")
    else:
      sys.stdout.write(" ")

    if stype:
      sys.stdout.write(stype[0])
    else:
      sys.stdout.write(" ")

    sys.stdout.write(": %9.4f %9.4f" % (abs(pos), slen))
    if stype == TYPE_SHORT or stype == TYPE_QUICKIE:
      sys.stdout.write(" %9.4f" % segmentLength(segment, segments))
    else:
      sys.stdout.write("          ")
    
    if schap != None:
      sys.stdout.write(" %9.4f" % schap)
    else:
      sys.stdout.write("          ")

    sys.stdout.write(" %9.4f" % splen)
      
    sys.stdout.write("  ")
    sys.stdout.write(str(sblack))
    sys.stdout.write("  ")
    sys.stdout.write(str(ssil))
    sys.stdout.write("\n")

  sys.stdout.write("\n")
  sys.stdout.flush()

def countShorts(segments):
  epnum = 0
  for seg in segments:
    if seg[SEG_TYPE] == TYPE_SHORT:
      epnum += 1
  return epnum
  
quickies = []
if re.match("^[-+]?[0-9]+(\.[0-9]+)?$", args.quickies):
  quickies.append(int(args.quickies))
  quickies.append(quickies[0])
elif re.match("^[0-9]+(.[0-9]+)?-[0-9]+(\.[0-9]+)?$", args.quickies):
  times = args.quickies.split("-")
  quickies.append(int(times[0]))
  quickies.append(int(times[1]))

args.titlelen = float(args.titlelen)
args.creditlen = float(args.creditlen)
args.minlength = float(args.minlength)
  
episodes = []
if os.path.isfile(args.series):
  f = open(args.series, 'rU')
  try:
    reader = csv.reader(f)
    for row in reader:
      epnum = re.split(" *x *", row[CSV_EPISODE])
      dvdnum = re.split(" *x *", row[CSV_DVDEP])
      epid = epnum[0] + "x" + epnum[1].zfill(2)
      info = [epid, int(epnum[0]), int(epnum[1]), int(dvdnum[0]), float(dvdnum[1]), \
                row[CSV_TITLE], row[CSV_ORIGDATE]]
      episodes.append(info)
  finally:
    f.close()

else:
  t = tvdb_api.Tvdb()
  show = t[args.series]
  for season in show:
    for epnum in show[season]:
      episode = show[season][epnum]
      epid = episode['seasonnumber'] + "x" + episode['episodenumber'].zfill(2)
      if episode['dvd_season'] and episode['dvd_episodenumber']:
        info = [epid, int(episode['seasonnumber']), int(episode['episodenumber']), \
                  int(episode['dvd_season']), float(episode['dvd_episodenumber']), \
                  episode['episodename'], episode['firstaired']]
        episodes.append(info)
      elif not args.quiet:
        print "No DVD info for"
        print episode
        if args.dvdmissing:
          info = [epid, int(episode['seasonnumber']), int(episode['episodenumber']), \
                    int(episode['seasonnumber']), float(episode['episodenumber']), \
                    episode['episodename'], episode['firstaired']]
          episodes.append(info)
episodes = sorted(episodes, key=itemgetter(EP_DVDSEASON, EP_DVDEPISODE))

if args.files:
  videos = args.files
else:
  videos = [file for file in glob.glob("[0-9]x[0-9][0-9].mkv")]
  videos.sort()

transcode = "--transcode"
if args.notranscode:
  transcode = ""
  
for filename in videos:
  video, ext = os.path.splitext(filename)

  episode = guessEpisode(filename)
  epindex = episodes.index(episode)

  cmd = "vidinf %s | grep ID_LENGTH | sed -e 's/ID_LENGTH=//'" % filename
  process = os.popen(cmd)
  vlen = float(process.read())
  process.close()

  chapters = loadChapters(filename, vlen)

  numshorts = 0
  shortindex = epindex
  dvdep = int(episode[EP_DVDEPISODE])
  dvdep2 = int(episodes[shortindex][EP_DVDEPISODE])
  while int(episodes[shortindex][EP_DVDEPISODE]) == int(episode[EP_DVDEPISODE]):
    numshorts += 1
    shortindex += 1
    dvdep2 = int(episodes[shortindex][EP_DVDSEASON])
    
  findBlack(filename)
  findSilence(filename)

  segments = loadSplits(filename)

  if args.debug:
    printSegments(segments)
  
  if segments[0][SEG_LEN] < 3:
    if segments[0][SEG_CHAP] != None:
      segments[1][SEG_CHAP] = abs(segments[1][SEG_POS])
    del segments[0]
    
  while segments[-1][SEG_LEN] < args.creditlen and \
        args.creditlen - (segments[-2][SEG_LEN] + segments[-1][SEG_LEN]) > -10:
    segments[-2][SEG_LEN] += segments[-1][SEG_LEN]
    del segments[-1]

  if segments[-1][SEG_LEN] < args.creditlen or segments[-1][SEG_LEN] - args.creditlen < 20:
    segments[-1][SEG_TYPE] = TYPE_CREDITS
  else:
    segments.append(segmentRow(vlen, 0.0, segType=TYPE_CREDITS))

  didtitle = False
  pos = 0
  endpos = len(segments) - 1
  while pos < endpos:
    segment = segments[pos]
    prevc = None
    if pos:
      prevc = segments[pos - 1]
    nextc = segments[pos + 1]

    clen = segment[SEG_LEN]
    qpercent = clen / quickies[0] * 100

    if clen >= quickies[0] and clen <= quickies[1] and \
          (segment[SEG_POS] > 0 or \
             (not prevc or \
              (prevc[SEG_TYPE] and segment[SEG_POS] > 0) or \
              (prevc[SEG_TYPE] and prevc[SEG_TYPE] != TYPE_QUICKIE)) or \
             segment[SEG_SPLEN] > 2):
      quickie = True
      if len(chapters) and prevc and prevc[SEG_TYPE] == TYPE_QUICKIE:
        achap = nearestChapter(abs(segment[SEG_POS]))
        bchap = nearestChapter(abs(nextc[SEG_POS]))
        if not achap and not bchap:
          quickie = False
          if args.debug:
            print "FAR"
      if quickie:
        segment[SEG_TYPE] = TYPE_QUICKIE
        if args.debug:
          print "QUICKIE", segment
        if prevc and prevc[SEG_TYPE] == TYPE_QUICKIE:
          chap = nearestChapter(abs(prevc[SEG_POS]))
          if chap and abs(chap - prevc[SEG_POS]) < abs(chap - segment[SEG_POS]):
            segment[SEG_TYPE] = None
          else:
            prevc[SEG_TYPE] = None
    elif abs(clen - args.titlelen) < MARGIN and not didtitle and pos < 3:
      segment[SEG_TYPE] = TYPE_TITLE
      didtitle = True
    elif clen < quickies[0] and segment[SEG_POS] > 0 and \
          (nextc[SEG_POS] < 0 or nextc[SEG_SPLEN] < 0.5) and \
          clen + nextc[SEG_LEN] >= quickies[0] and clen + nextc[SEG_LEN] <= quickies[1] and \
          qpercent > 50 and (not prevc or prevc[SEG_TYPE] != TYPE_QUICKIE):
      if args.debug:
        print "JOIN", qpercent, clen, segment, nextc
      segment[SEG_TYPE] = TYPE_QUICKIE
      nextc[SEG_TYPE] = TYPE_PREV
      clen += nextc[SEG_LEN]
      pos += 1
      nextc = segments[pos]
      while clen > quickies[0] and nextc[SEG_SPLEN] < 0.6 and \
            clen + nextc[SEG_LEN] < quickies[1] and nextc[SEG_POS] < 0:
        if args.debug:
          print "DOUBLE JOIN", qpercent, clen, segment, nextc
        nextc[SEG_TYPE] = TYPE_PREV
        clen += nextc[SEG_LEN]
        pos += 1
        nextc = segments[pos]
    pos += 1

  if not didtitle and segments[0][SEG_LEN] < (args.titlelen + MARGIN) and \
        (not segments[0][SEG_TYPE] or segments[0][SEG_TYPE] == TYPE_QUICKIE):
    tseg = segments[0]
    tseg[SEG_TYPE] = TYPE_TITLE
    tlen = segmentLength(tseg, segments)
    tpos = 1
    while tlen < args.titlelen and \
          abs(args.titlelen - (tlen + segments[tpos][SEG_LEN])) < MARGIN:
      segments[tpos][SEG_TYPE] = TYPE_PREV
      tlen += segments[tpos][SEG_LEN]
      tpos += 1

  # If there are chapter markers then quickies/shorts will be at each one
  if len(chapters):
    for seg in segments:
      if seg[SEG_CHAP] != None or segments.index(seg) == 0:
        if seg[SEG_TYPE] == TYPE_TITLE:
          nextc = findNext(seg, segments)
          if nextc[SEG_TYPE] == TYPE_QUICKIE:
            nextc = findNext(nextc, segments)
          nextc[SEG_TYPE] = TYPE_SHORT
        elif seg[SEG_TYPE] == TYPE_QUICKIE:
          nextc = findNext(seg, segments)
          nextc[SEG_TYPE] = TYPE_SHORT
        else:
          seg[SEG_TYPE] = TYPE_SHORT
      
  if args.debug:
    print
    printSegments(segments)

  avglen = 0
  for segment in segments:
    if not segment[SEG_TYPE]:
      avglen += abs(segment[SEG_LEN])
  avglen = avglen / numshorts
  if args.debug:
    print "Average short len:", avglen
  
  clen = 0
  for curc in segments:
    pos = segments.index(curc)
    prevc = None
    if pos:
      prevc = segments[pos - 1]
    nextc = None
    if pos < len(segments) - 1:
      nextc = segments[pos + 1]
    if not curc[SEG_TYPE]:
      if not prevc or prevc[SEG_TYPE] == TYPE_QUICKIE or prevc[SEG_TYPE] == TYPE_TITLE:
        curc[SEG_TYPE] = TYPE_SHORT
        clen = curc[SEG_LEN]
        if args.debug:
          print "SHORT", curc
      else:
        curc[SEG_TYPE] = TYPE_PREV
        plen = clen
        clen += curc[SEG_LEN]

        if plen < args.minlength:
          continue
        
        overpercent = (clen - avglen) / curc[SEG_LEN] * 100
        if overpercent > 50 and not nextc[SEG_SILENCE]:
          if args.debug:
            print "OVER", curc[SEG_POS], nextc[SEG_POS], prevc[SEG_POS], overpercent, plen, clen
          curc[SEG_TYPE] = TYPE_SHORT
          clen = curc[SEG_LEN]
          continue

        underpercent = (avglen - clen) / avglen * 100
        badsplit = curc[SEG_POS] < 0 and curc[SEG_SPLEN] < 0.8
        test1 = clen > avglen and (overpercent > 110 or curc[SEG_POS] > 0 or \
                                     curc[SEG_SPLEN] > 1.5) and not badsplit
        test2 = not nextc[SEG_TYPE] and clen > args.minlength and \
                           clen + nextc[SEG_LEN] > avglen and nextc[SEG_POS] > 0 \
                           and not badsplit
        test3 = nextc[SEG_POS] > 0 and underpercent > 0 and underpercent < 8 and \
                 clen + nextc[SEG_LEN] < avglen and clen - curc[SEG_LEN] >= args.minlength
        test4 = clen >= args.minlength and curc[SEG_SILENCE] != None
        if test1 or test2 or test3 or test4:
          curc[SEG_TYPE] = TYPE_SHORT
          if args.debug:
            print "END", curc[SEG_POS], nextc[SEG_POS], curc[SEG_SPLEN]
            print "Length:", clen, avglen
            print "Under/Over:", underpercent, overpercent
            print "Tests:", test1, test2, test3, test4
          clen = curc[SEG_LEN]

  for segment in segments:
    if segment[SEG_CHAP] and segment[SEG_TYPE] != TYPE_SHORT and \
          segment[SEG_TYPE] != TYPE_QUICKIE and segment[SEG_TYPE] != TYPE_TITLE:
      if args.debug:
        print "NOSHORT", segment
      nextc = segments[segments.index(segment)]
      if nextc[SEG_TYPE] != TYPE_SHORT:
        if args.debug:
          print "MARKED", segment, nextc
        segment[SEG_TYPE] = TYPE_SHORT
      
  if args.debug:
    print
    printSegments(segments)
    
  i = 0
  while i < len(segments) - 1:
    segment = segments[i]
    if segment[SEG_TYPE] == TYPE_SHORT:
      slen = segmentLength(segment, segments)
      if slen < args.minlength:
        prevc = findPrevious(segment, segments)
        nextc = findNext(segment, segments)
        if args.debug:
          print "TOO SHORT", segment[SEG_POS],
          if prevc:
            print prevc[SEG_POS], prevc[SEG_TYPE],
          else:
            print "None",
          if nextc:
            print nextc[SEG_POS], nextc[SEG_TYPE]
          else:
            print "None"
        if segment[SEG_CHAP] or not prevc or prevc[SEG_TYPE] != TYPE_SHORT:
          if nextc:
            if not nextc[SEG_CHAP]:
              if args.debug:
                print "MERGING DOWN"
              nextc[SEG_TYPE] = TYPE_PREV
            else:
              if args.debug:
                print "IGNORING"
              i += 1
          else:
            if args.debug:
              print "SHIFTING UP"
            prevc[SEG_TYPE] = TYPE_SHORT
            segment[SEG_TYPE] = TYPE_PREV
            i = segments.index(prevc)
          i -= 1
        else:
          if i and segments[i - 1][SEG_TYPE] == TYPE_PREV:
            plen = None
            nlen = None
            if prevc:
              plen = segmentLength(prevc, segments)
            if nextc:
              nlen = segmentLength(nextc, segments)
            if nlen and plen and nlen < plen and nextc[SEG_TYPE] == TYPE_SHORT:
              if abs((plen + segment[SEG_LEN]) - (slen - segment[SEG_LEN] + nlen)) < 4:
                if args.debug:
                  print "SHIFTING UP", slen, plen
                segment[SEG_TYPE] = TYPE_PREV
                if segments[i + 1][SEG_TYPE] == TYPE_PREV:
                  segments[i + 1][SEG_TYPE] = TYPE_SHORT
              else:
                if args.debug:
                  print "JOINING NEXT", slen, plen, nlen, plen + segment[SEG_LEN], slen - segment[SEG_LEN] + nlen
                nextc[SEG_TYPE] = TYPE_PREV
                i -= 1
            elif not prevc or plen > avglen:
              segment[SEG_TYPE] = TYPE_PREV
              if plen - segments[i - 1][SEG_LEN] < args.minlength:
                if args.debug:
                  print "MERGING UP"
              else:
                if args.debug:
                  print "SHIFTING UP", slen, plen, nlen
                segments[i - 1][SEG_TYPE] = TYPE_SHORT
                i -= 2
            else:
              if nlen and abs((slen + nlen) - avglen) < 20:
                if args.debug:
                  print "NEXTING3", slen, plen, nlen
                nextc[SEG_TYPE] = TYPE_PREV
                i -= 1
              elif prevc and abs(plen - args.minlength) < 10:
                if args.debug:
                  print "SPLITTING", plen, slen, nlen
                segment[SEG_TYPE] = TYPE_PREV
                if segments[i + 1][SEG_TYPE] == TYPE_PREV:
                  segments[i + 1][SEG_TYPE] = TYPE_SHORT
              else:
                if args.debug:
                  print "REMOVING"
                segment[SEG_TYPE] = TYPE_PREV
          else:
            if args.debug:
              print "REMOVING"
            segment[SEG_TYPE] = TYPE_PREV
    i += 1

  if args.debug:
    print
    printSegments(segments)
    
  segments.append(segmentRow(vlen, 0.0))

  epnum = countShorts(segments)
  if epnum != numshorts:
    for seg in segments:
      if seg[SEG_TYPE] == TYPE_SHORT:
        slen = segmentLength(seg, segments)
        if slen < avglen:
          nextc = findNext(seg, segments)
          nlen = segmentLength(nextc, segments)
          if nlen < avglen and not nextc[SEG_CHAP] and nextc[SEG_TYPE] == TYPE_SHORT:
            if args.debug:
              print "COMBINING", seg[SEG_POS], nextc[SEG_POS]
            nextc[SEG_TYPE] = TYPE_PREV
            
    epnum = countShorts(segments)
    if epnum != numshorts:
      print "ABORTING. WRONG number of shorts:", epnum, numshorts
      sys.exit(1)
  
  quickie = 0
  epnum = 0
  for current in segments[:-1]:
    ctype = current[SEG_TYPE]
    if ctype == TYPE_QUICKIE:
      quickie += 1
      title = "Quickie %i" % quickie
      ep = episodes[epindex + epnum]
      eptitle = "%s.%i %s%s" % (video, quickie + epnum, title, ext)
      alttitle = None
    elif ctype == TYPE_SHORT:
      ep = episodes[epindex + epnum]
      title = re.sub("[:/]", "-", re.sub("[.!?]$", "", ep[EP_TITLE]))
      eptitle = "%s.%i %s%s" % (video, quickie + epnum + 1, title, ext)
      alttitle = "%s %s%s" % (ep[EP_ID], title, ext)
      epnum += 1

    begin = abs(current[SEG_POS])
    end = begin + segmentLength(current, segments)
    if current[SEG_CHAP]:
      begin = current[SEG_CHAP]
    
    if args.split:
      if ctype == TYPE_QUICKIE or ctype == TYPE_SHORT:
        temp = video + "_tmp" + ext
        cmd = "split-video %s --output \"%s\" \"%s\" %f-%f" % (transcode, temp, filename, begin, end)
        print cmd
        os.system(cmd)
        cmd = "adjust-volume \"%s\" \"%s\" > /dev/null 2>&1" % (temp, eptitle)
        print cmd
        os.system(cmd)
        os.remove(temp)
        if alttitle:
          print "Linking " + eptitle + " to " + alttitle
          if os.path.exists(alttitle):
            os.remove(alttitle)
          os.link(eptitle, alttitle)
    elif ctype != TYPE_PREV:
      print "# " + ctype, end - begin
      if ctype == TYPE_SHORT or ctype == TYPE_QUICKIE:
        print "# " + title
      print begin
